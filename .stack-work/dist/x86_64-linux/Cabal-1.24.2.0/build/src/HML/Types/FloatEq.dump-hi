
==================== FINAL INTERFACE ====================
2017-11-20 04:54:02.592956 UTC

interface haslearned-0.1.0.0-1MYfuCwSlxlBXzMx3VqeuN:HML.Types.FloatEq 8002
  interface hash: bb1e8349b39d861ce7466da69d626adc
  ABI hash: aaef18f4fee7dce4a8008fb64f6d3aac
  export-list hash: 9c9a5299540dec8feff1f9e464e65cb8
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 6cd24486e4830f0aa331269f38aae8d9
  sig of: Nothing
  used TH splices: False
  where
exports:
  HML.Types.FloatEq.FloatEq{HML.Types.FloatEq.~/ HML.Types.FloatEq.~=}
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj
                      integer-gmp-1.0.0.1
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      split-0.2.3.2@split-0.2.3.2-CJl40zTyCIV16Pr60nb7CT
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.CG
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Element
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Util
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Vector
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Numeric.Matrix
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Numeric.Vector
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Fusion.Bundle
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Devel
                         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Matrix
                         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Modular
                         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Numeric
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Storable
import  -/  base-4.9.1.0:Data.Either 20b09ef8d0a5b74fdec011c40c1587f5
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Matrix 53638184b736d49afc503f161ceef1e2
import  -/  hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Numeric.LinearAlgebra ee42d53f4ea01fd23be32d73fe10df7b
import  -/  hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Numeric.LinearAlgebra.Data 9ebd9664f9d22e6d69a44fbe0dc7ae55
bce3ebdcdcb30d6f18079a2dd39ae2af
  $dm~/ :: HML.Types.FloatEq.FloatEq a => a -> a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ a
                   ($dFloatEq :: HML.Types.FloatEq.FloatEq a)
                   (x :: a)
                   (y :: a) ->
                 GHC.Classes.not (HML.Types.FloatEq.~= @ a $dFloatEq x y)) -}
ccb67853901d27eaa7e8788a8db1240b
  $dm~= :: HML.Types.FloatEq.FloatEq a => a -> a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ a
                   ($dFloatEq :: HML.Types.FloatEq.FloatEq a)
                   (x :: a)
                   (y :: a) ->
                 GHC.Classes.not (HML.Types.FloatEq.~/ @ a $dFloatEq x y)) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqDouble :: HML.Types.FloatEq.FloatEq GHC.Types.Double
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.Double
                  HML.Types.FloatEq.$fFloatEqDouble_$c~=
                  HML.Types.FloatEq.$fFloatEqDouble_$c~/ -}
b59ddb5ce68e3815f47dc2a81a7ba049
  $fFloatEqDouble_$c~/ ::
    GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Double) (y :: GHC.Types.Double) ->
                 case HML.Types.FloatEq.$fFloatEqDouble_$c~= x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
36166e31b9e56bc4109497fd2a222976
  $fFloatEqDouble_$c~= ::
    GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Double) (w1 :: GHC.Types.Double) ->
                 case w of ww { GHC.Types.D# ww1 ->
                 case w1 of ww2 { GHC.Types.D# ww3 ->
                 HML.Types.FloatEq.$w$c~= ww1 ww3 } }) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqEither ::
    HML.Types.FloatEq.FloatEq b =>
    HML.Types.FloatEq.FloatEq (Data.Either.Either a b)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ b
                      @ a
                      ($dFloatEq :: HML.Types.FloatEq.FloatEq b).
                  @ (Data.Either.Either a b)
                  (HML.Types.FloatEq.$fFloatEqEither_$c~= @ b @ a $dFloatEq)
                  (HML.Types.FloatEq.$fFloatEqEither_$c~/ @ b @ a $dFloatEq) -}
4550b11fa8fd247203a3a5029e3a11a0
  $fFloatEqEither1 :: [b] -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqEither_$c~/ ::
    HML.Types.FloatEq.FloatEq b =>
    Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   ($dFloatEq :: HML.Types.FloatEq.FloatEq b)
                   (x :: Data.Either.Either a b)
                   (y :: Data.Either.Either a b) ->
                 case HML.Types.FloatEq.$fFloatEqEither_$c~=
                        @ b
                        @ a
                        $dFloatEq
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqEither_$c~= ::
    HML.Types.FloatEq.FloatEq b =>
    Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><L,U>,
     Unfolding: (\ @ b
                   @ a
                   ($dFloatEq :: HML.Types.FloatEq.FloatEq b)
                   (e1 :: Data.Either.Either a b)
                   (e2 :: Data.Either.Either a b) ->
                 let {
                   rs :: [b]
                   = Data.Either.rights1
                       @ a
                       @ b
                       (GHC.Types.:
                          @ (Data.Either.Either a b)
                          e1
                          (GHC.Types.:
                             @ (Data.Either.Either a b)
                             e2
                             (GHC.Types.[] @ (Data.Either.Either a b))))
                 } in
                 case GHC.List.$wlenAcc @ b rs 0# of ww2 {
                   DEFAULT
                   -> HML.Types.FloatEq.~=
                        @ b
                        $dFloatEq
                        (case rs of wild { [] -> GHC.List.badHead @ b : x ds1 -> x })
                        (HML.Types.FloatEq.$fFloatEqEither1
                           @ b
                           rs
                           (GHC.List.lastError @ b))
                   0# -> GHC.Types.True }) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqInt :: HML.Types.FloatEq.FloatEq GHC.Types.Int
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.Int
                  HML.Types.FloatEq.$fFloatEqInt_$c~=
                  HML.Types.FloatEq.$fFloatEqInt_$c~/ -}
7a958eba2fc4adf1f51c6c6e51d852dd
  $fFloatEqInt_$c~/ ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (y :: GHC.Types.Int) ->
                 case x of wild { GHC.Types.I# x1 ->
                 case y of wild1 { GHC.Types.I# y1 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# x1 y1) of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
ba92a7f4aa04fbe89cfd344619f33774
  $fFloatEqInt_$c~= ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (0, True, True) GHC.Classes.eqInt -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqMatrix ::
    (Internal.Matrix.Element a, HML.Types.FloatEq.FloatEq a) =>
    HML.Types.FloatEq.FloatEq (Internal.Matrix.Matrix a)
  DFunId
  {- Arity: 2,
     Strictness: <L,U(U,A,C(C1(C1(C1(C1(C1(C1(U))))))),A,A,A,A,A,A,A,A)><L,U(U,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dElement :: Internal.Matrix.Element a)
                      ($dFloatEq :: HML.Types.FloatEq.FloatEq a).
                  @ (Internal.Matrix.Matrix a)
                  (HML.Types.FloatEq.$fFloatEqMatrix_$c~= @ a $dElement $dFloatEq)
                  (HML.Types.FloatEq.$fFloatEqMatrix_$c~/ @ a $dElement $dFloatEq) -}
18147d6f70983a15ce650402fa0a0fbf
  $fFloatEqMatrix1 :: [[a]] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
cac180b15a685def2dd665d7b091c9ad
  $fFloatEqMatrix2 :: [[a]] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqMatrix_$c~/ ::
    (Internal.Matrix.Element a, HML.Types.FloatEq.FloatEq a) =>
    Internal.Matrix.Matrix a
    -> Internal.Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,U(U,A,C(C1(C1(C1(C1(C1(C1(U))))))),A,A,A,A,A,A,A,A)><L,1*U(1*U,A)><S(LSLLLLL),1*U(U,U,U,U,U,U,U)><S(LSLLLLL),1*U(U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dElement :: Internal.Matrix.Element a)
                   ($dFloatEq :: HML.Types.FloatEq.FloatEq a)
                   (x :: Internal.Matrix.Matrix a)
                   (y :: Internal.Matrix.Matrix a) ->
                 case HML.Types.FloatEq.$fFloatEqMatrix_$c~=
                        @ a
                        $dElement
                        $dFloatEq
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqMatrix_$c~= ::
    (Internal.Matrix.Element a, HML.Types.FloatEq.FloatEq a) =>
    Internal.Matrix.Matrix a
    -> Internal.Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,U(U,A,C(C1(C1(C1(C1(C1(C1(U))))))),A,A,A,A,A,A,A,A)><L,1*U(1*U,A)><S(LSLLLLL),1*U(U,U,U,U,U,U,U)><S(LSLLLLL),1*U(U,U,U,U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: Internal.Matrix.Element a)
                   (w1 :: HML.Types.FloatEq.FloatEq a)
                   (w2 :: Internal.Matrix.Matrix a)
                   (w3 :: Internal.Matrix.Matrix a) ->
                 case w2 of ww { Internal.Matrix.Matrix ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case w3 of ww8 { Internal.Matrix.Matrix ww9 ww10 ww11 ww12 ww13 ww14 ww15 ->
                 HML.Types.FloatEq.$w$c~=1
                   @ a
                   w
                   w1
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15 } }) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqMatrix_$c~=1 ::
    HML.Types.FloatEq.FloatEq a => [a] -> [a] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U(1*U,A)><S,U><S,U>,
     Unfolding: (\ @ a
                   ($dFloatEq :: HML.Types.FloatEq.FloatEq a)
                   (l :: [a])
                   (m :: [a]) ->
                 case GHC.List.$wlenAcc @ a l 0# of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc @ a m 0# of ww1 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww2 ww1) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> let {
                        f :: a -> a -> GHC.Types.Bool = HML.Types.FloatEq.~= @ a $dFloatEq
                      } in
                      letrec {
                        go :: [a] -> [a] -> Data.Monoid.All
                          {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                        = \ (ds :: [a]) (_ys :: [a]) ->
                          case ds of wild1 {
                            [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                            : ipv ipv1
                            -> case _ys of wild2 {
                                 [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                                 : ipv2 ipv3
                                 -> case f ipv ipv2 of wild3 {
                                      GHC.Types.False
                                      -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                                      GHC.Types.True -> go ipv1 ipv3 } } }
                      } in
                      (go l m) `cast` (Data.Monoid.N:All[0]) } } }) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqMaybe ::
    HML.Types.FloatEq.FloatEq a =>
    HML.Types.FloatEq.FloatEq (GHC.Base.Maybe a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dFloatEq :: HML.Types.FloatEq.FloatEq a).
                  @ (GHC.Base.Maybe a)
                  (HML.Types.FloatEq.$fFloatEqMaybe_$c~= @ a $dFloatEq)
                  (HML.Types.FloatEq.$fFloatEqMaybe_$c~/ @ a $dFloatEq) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqMaybe_$c~/ ::
    HML.Types.FloatEq.FloatEq a =>
    GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloatEq :: HML.Types.FloatEq.FloatEq a)
                   (x :: GHC.Base.Maybe a)
                   (y :: GHC.Base.Maybe a) ->
                 case x of wild {
                   GHC.Base.Nothing
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just x1
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just y1
                        -> case HML.Types.FloatEq.~= @ a $dFloatEq x1 y1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEqMaybe_$c~= ::
    HML.Types.FloatEq.FloatEq a =>
    GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dFloatEq :: HML.Types.FloatEq.FloatEq a)
                   (ds :: GHC.Base.Maybe a)
                   (ds1 :: GHC.Base.Maybe a) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just x
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just y -> HML.Types.FloatEq.~= @ a $dFloatEq x y } }) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEq[] ::
    HML.Types.FloatEq.FloatEq a => HML.Types.FloatEq.FloatEq [a]
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dFloatEq :: HML.Types.FloatEq.FloatEq a).
                  @ [a]
                  (HML.Types.FloatEq.$fFloatEqMatrix_$c~=1 @ a $dFloatEq)
                  (HML.Types.FloatEq.$fFloatEq[]_$c~/ @ a $dFloatEq) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $fFloatEq[]_$c~/ ::
    HML.Types.FloatEq.FloatEq a => [a] -> [a] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U(1*U,A)><S,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dFloatEq :: HML.Types.FloatEq.FloatEq a)
                   (x :: [a])
                   (y :: [a]) ->
                 case HML.Types.FloatEq.$fFloatEqMatrix_$c~=1
                        @ a
                        $dFloatEq
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
da8bca5c2121df2c29d32a06d5cc56ee
  $tc'C:FloatEq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13403044413355620905##
                   16538622764845490718##
                   HML.Types.FloatEq.$trModule
                   HML.Types.FloatEq.$tc'C:FloatEq1) -}
2f8a50b66d26d253f237d8fb5b419158
  $tc'C:FloatEq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:FloatEq"#) -}
c81669601b98bdb7005d748a7427aa26
  $tcFloatEq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4806164458471261778##
                   4167934073316360979##
                   HML.Types.FloatEq.$trModule
                   HML.Types.FloatEq.$tcFloatEq1) -}
85e82ee882d83ad689be9f8be3ef3573
  $tcFloatEq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "FloatEq"#) -}
5bdf5568b5c204277d0ffc87462aa262
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   HML.Types.FloatEq.$trModule2
                   HML.Types.FloatEq.$trModule1) -}
cffc7370c90889d7b0bd023bec7536b8
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HML.Types.FloatEq"#) -}
77c04c3d458e0c247b0ff6b7b3d870ce
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "haslearned-0.1.0.0-1MYfuCwSlxlBXzMx3VqeuN"#) -}
bd83e9c8bd168322aa403cef0d548520
  $w$c~= :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Double#) (ww1 :: GHC.Prim.Double#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==## ww 0.0##) of wild {
                   GHC.Types.False
                   -> case GHC.Prim./## (GHC.Prim.-## ww1 ww) ww of wild2 { DEFAULT ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==## wild2 0.0##) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>## wild2 0.0##) of wild4 {
                             GHC.Types.False
                             -> GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<## (GHC.Prim.negateDouble# wild2) 5.0e-11##)
                             GHC.Types.True
                             -> GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<## wild2 5.0e-11##) }
                        GHC.Types.True -> GHC.Types.True } }
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==## ww1 0.0##) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>## ww1 0.0##) of wild2 {
                             GHC.Types.False
                             -> GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<## (GHC.Prim.negateDouble# ww1) 5.0e-11##)
                             GHC.Types.True
                             -> GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<## ww1 5.0e-11##) }
                        GHC.Types.True -> GHC.Types.True } }) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  $w$c~=1 ::
    (Internal.Matrix.Element a, HML.Types.FloatEq.FloatEq a) =>
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Types.Bool
  {- Arity: 16,
     Strictness: <L,U(U,A,C(C1(C1(C1(C1(C1(C1(U))))))),A,A,A,A,A,A,A,A)><L,1*U(1*U,A)><L,U><S,U><L,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Internal.Matrix.Element a)
                   (w1 :: HML.Types.FloatEq.FloatEq a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.Int#)
                   (ww5 :: GHC.Prim.Addr#)
                   (ww6 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww7 :: GHC.Prim.Int#)
                   (ww8 :: GHC.Prim.Int#)
                   (ww9 :: GHC.Prim.Int#)
                   (ww10 :: GHC.Prim.Int#)
                   (ww11 :: GHC.Prim.Int#)
                   (ww12 :: GHC.Prim.Addr#)
                   (ww13 :: GHC.ForeignPtr.ForeignPtrContents) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww1 ww8) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> HML.Types.FloatEq.$fFloatEqMatrix_$c~=1
                        @ a
                        w1
                        (HML.Types.FloatEq.$fFloatEqMatrix2
                           @ a
                           (Internal.Matrix.$wtoLists @ a w ww ww1 ww2 ww3 ww4 ww5 ww6))
                        (HML.Types.FloatEq.$fFloatEqMatrix1
                           @ a
                           (Internal.Matrix.$wtoLists
                              @ a
                              w
                              ww7
                              ww8
                              ww9
                              ww10
                              ww11
                              ww12
                              ww13)) }) -}
11a737c0ca9a7a47bf51c2c045ebe8ce
  class FloatEq a where
    (~=) :: a -> a -> GHC.Types.Bool
    (~/) :: a -> a -> GHC.Types.Bool
instance HML.Types.FloatEq.FloatEq [GHC.Types.Double]
  = HML.Types.FloatEq.$fFloatEqDouble
instance HML.Types.FloatEq.FloatEq [Data.Either.Either]
  = HML.Types.FloatEq.$fFloatEqEither
instance HML.Types.FloatEq.FloatEq [GHC.Types.Int]
  = HML.Types.FloatEq.$fFloatEqInt
instance HML.Types.FloatEq.FloatEq [Internal.Matrix.Matrix]
  = HML.Types.FloatEq.$fFloatEqMatrix
instance HML.Types.FloatEq.FloatEq [GHC.Base.Maybe]
  = HML.Types.FloatEq.$fFloatEqMaybe
instance HML.Types.FloatEq.FloatEq [[]]
  = HML.Types.FloatEq.$fFloatEq[]
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

