
==================== FINAL INTERFACE ====================
2017-11-20 04:54:03.79466 UTC

interface haslearned-0.1.0.0-1MYfuCwSlxlBXzMx3VqeuN:HML.FileIO.AppIO 8002
  interface hash: d011333181473b042995b4393739f5de
  ABI hash: 996f0663a9234630e6f09df1c28d64d3
  export-list hash: ec1bc10e02b198719ccbde6835fb6842
  orphan hash: 28cc280e872d88bf34c0d9e2e3a6cd33
  flag hash: bc3ee18da6820b4b049eac41cafbc431
  sig of: Nothing
  used TH splices: False
  where
exports:
  HML.FileIO.AppIO.appIOFail
  HML.FileIO.AppIO.confirmAtom
  HML.FileIO.AppIO.liftAppIO
  HML.FileIO.AppIO.maybeToAppIO
  HML.FileIO.AppIO.runAppIO
  HML.FileIO.AppIO.AppIO
  HML.FileIO.AppIO.ConduitAppIO
  HML.FileIO.AppIO.Confirmer
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1
                      attoparsec-0.13.1.0@attoparsec-0.13.1.0-3ql4hcH9pGfBAlE21oqFTQ
                      base-4.9.1.0
                      base16-bytestring-0.1.1.6@base16-bytestring-0.1.1.6-4E2p94lTx8gIceMhu8Kl9o
                      base64-bytestring-1.0.0.1@base64-bytestring-1.0.0.1-4O9TExPPz6eI82Yj7L4SIj
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      bytestring-conversion-0.3.1@bytestring-conversion-0.3.1-KSK6l7QmbIf1TbIBILuJUV
                      case-insensitive-1.2.0.10@case-insensitive-1.2.0.10-1D5OUKQ7UrJ7IpOe0di4Un
                      chunked-data-0.3.0@chunked-data-0.3.0-OOunTfArGE2y1nE8RKgW4
                      conduit-1.2.12.1@conduit-1.2.12.1-CTYKTJmwFo81r4LrAKDD8i
                      conduit-combinators-1.1.1@conduit-combinators-1.1.1-GtFbL9AxEDH5Bi4dHJqDcv
                      conduit-extra-1.1.17@conduit-extra-1.1.17-LHyPtC0nGlzDcgVxOcd4h4
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 directory-1.3.0.0@directory-1.3.0.0
                      double-conversion-2.0.2.0@double-conversion-2.0.2.0-Ls1AZoWRK0TKpzR8XpTsSD
                      exceptions-0.8.3@exceptions-0.8.3-ADEDRATtUrMK1JW4zMQ9U
                      filepath-1.4.1.1@filepath-1.4.1.1
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      integer-gmp-1.0.0.1
                      integer-logarithms-1.0.2@integer-logarithms-1.0.2-92lMiWV9mmYAwfMEYgfQ0D
                      lifted-base-0.2.3.11@lifted-base-0.2.3.11-Ei0JSPdt7KOCD2HIA5jFqV
                      mmorph-1.0.9@mmorph-1.0.9-5bASEvmIkr5CpdAYXwPsn0
                      monad-control-1.0.2.2@monad-control-1.0.2.2-1Ci8dYJ8Tb7E3HTcTqOb8l
                      mono-traversable-1.0.4.0@mono-traversable-1.0.4.0-4NjleFtgjZEBUffX1jBk6F
                      mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      mwc-random-0.13.6.0@mwc-random-0.13.6.0-FYg9HqO0pqB8vcniiPVzVy
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      resourcet-1.1.9@resourcet-1.1.9-L2BUQrxWZMwDiwhcuyPuNi
                      scientific-0.3.5.2@scientific-0.3.5.2-FM2NdrNTcdbCDq9wuNnhIA
                      split-0.2.3.2@split-0.2.3.2-CJl40zTyCIV16Pr60nb7CT
                      stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve
                      streaming-commons-0.1.17@streaming-commons-0.1.17-6xuIA5RXrs65yyeq3HWIWP
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      transformers-base-0.4.4@transformers-base-0.4.4-GKSs0LKukAL8ymq2naFmrH
                      unix-2.7.2.1@unix-2.7.2.1
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC
                      vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ
                      vector-algorithms-0.7.0.1@vector-algorithms-0.7.0.1-1qlx0Hst1Fo5WZd0lT7Iw1
orphans: attoparsec-0.13.1.0@attoparsec-0.13.1.0-3ql4hcH9pGfBAlE21oqFTQ:Data.Attoparsec.ByteString.Char8
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve:Control.Monad.STM
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Fusion.Bundle
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
family instance modules: attoparsec-0.13.1.0@attoparsec-0.13.1.0-3ql4hcH9pGfBAlE21oqFTQ:Data.Attoparsec.Internal.Types
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         conduit-1.2.12.1@conduit-1.2.12.1-CTYKTJmwFo81r4LrAKDD8i:Data.Conduit.Internal.Conduit
                         conduit-1.2.12.1@conduit-1.2.12.1-CTYKTJmwFo81r4LrAKDD8i:Data.Conduit.Internal.Pipe
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         monad-control-1.0.2.2@monad-control-1.0.2.2-1Ci8dYJ8Tb7E3HTcTqOb8l:Control.Monad.Trans.Control
                         mono-traversable-1.0.4.0@mono-traversable-1.0.4.0-4NjleFtgjZEBUffX1jBk6F:Data.MonoTraversable
                         mono-traversable-1.0.4.0@mono-traversable-1.0.4.0-4NjleFtgjZEBUffX1jBk6F:Data.NonNull
                         mono-traversable-1.0.4.0@mono-traversable-1.0.4.0-4NjleFtgjZEBUffX1jBk6F:Data.Sequences
                         mwc-random-0.13.6.0@mwc-random-0.13.6.0-FYg9HqO0pqB8vcniiPVzVy:System.Random.MWC
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Data.Primitive.Array
                         resourcet-1.1.9@resourcet-1.1.9-L2BUQrxWZMwDiwhcuyPuNi:Control.Monad.Trans.Resource.Internal
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashSet
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Primitive
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Storable
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed.Base
import  -/  attoparsec-0.13.1.0@attoparsec-0.13.1.0-3ql4hcH9pGfBAlE21oqFTQ:Data.Attoparsec.ByteString 95552c58dcce0357c7f3698b92a0ce9b
import  -/  attoparsec-0.13.1.0@attoparsec-0.13.1.0-3ql4hcH9pGfBAlE21oqFTQ:Data.Attoparsec.ByteString.Internal eadd217906370ab7c792393e893ec0ea
import  -/  base-4.9.1.0:Data.Either 20b09ef8d0a5b74fdec011c40c1587f5
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.Void 3c797a21706a51366e113ccecc813336
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString 43e99fdac51908da414a28958688da64
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Internal 89cda42ec946d9d6577dd41ab95d523e
import  -/  bytestring-conversion-0.3.1@bytestring-conversion-0.3.1-KSK6l7QmbIf1TbIBILuJUV:Data.ByteString.Conversion ff5b7c2f893209b9038238a8e75ea663
import  -/  bytestring-conversion-0.3.1@bytestring-conversion-0.3.1-KSK6l7QmbIf1TbIBILuJUV:Data.ByteString.Conversion.From 6e6788790b799ba6a2f4a1563369b1f4
import  -/  conduit-1.2.12.1@conduit-1.2.12.1-CTYKTJmwFo81r4LrAKDD8i:Data.Conduit 8d7ec43e22522a4dafe1e40081e3bcee
import  -/  conduit-1.2.12.1@conduit-1.2.12.1-CTYKTJmwFo81r4LrAKDD8i:Data.Conduit.Internal.Conduit cb2416e4318f4105196b90a1a4c4b9f2
import  -/  conduit-combinators-1.1.1@conduit-combinators-1.1.1-GtFbL9AxEDH5Bi4dHJqDcv:Conduit 4b8c71dec647b12e304799221bd3ba2e
import  -/  conduit-combinators-1.1.1@conduit-combinators-1.1.1-GtFbL9AxEDH5Bi4dHJqDcv:Data.Conduit.Combinators.Unqualified ad729553ca387c95a05a93841e33ba6e
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  resourcet-1.1.9@resourcet-1.1.9-L2BUQrxWZMwDiwhcuyPuNi:Control.Monad.Trans.Resource.Internal 50c93ad6ec81754501e8820a059dce55
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Class 45530f1305724ee3931a9be21b40ca7e
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Except cf549ed58fbe6804d519833d92803f4c
48aadca97d4c58bdf34034b7925f3abe
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (HML.FileIO.AppIO.$s$fApplicativeExceptT1 @ e)
                  (HML.FileIO.AppIO.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e
                     HML.FileIO.AppIO.$s$fApplicativeExceptT_$dFunctor
                     GHC.Base.$fMonadIO)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c*>
                     @ GHC.Types.IO
                     @ e
                     HML.FileIO.AppIO.$s$fApplicativeExceptT_$dFunctor
                     GHC.Base.$fMonadIO)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*
                     @ GHC.Types.IO
                     @ e
                     HML.FileIO.AppIO.$s$fApplicativeExceptT_$dFunctor
                     GHC.Base.$fMonadIO) -}
b2f9252269c3df2b471d7326c6339ed1
  $s$fApplicativeExceptT1 ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Unfolding: (\ @ e ->
                 Control.Monad.Trans.Except.$fFunctorExceptT
                   @ GHC.Types.IO
                   @ e
                   GHC.Base.$fFunctorIO) -}
d59bf3dc0d0a398f310f648b590a85c0
  $s$fApplicativeExceptT_$dFunctor :: GHC.Base.Functor GHC.Types.IO
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) GHC.Base.$fFunctorIO -}
5bf284189c48d13d84f09c409393d883
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e @ a (a1 :: a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (GHC.Types.IO (Data.Either.Either e a))
                   @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (\ (tpl :: GHC.Types.IO (Data.Either.Either e a)) -> tpl)
                     `cast`
                   (<GHC.Types.IO (Data.Either.Either e a)>_R
                    ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <e>_N <GHC.Types.IO>_R <a>_N))
                   (GHC.Base.returnIO
                      @ (Data.Either.Either e a)
                      (Data.Either.Right @ e @ a a1))) -}
e7f2bf22aecfda7f960980fb7b5d23a8
  $s$fMonadBaseControlbExceptT ::
    Control.Monad.Trans.Control.MonadBaseControl
      GHC.Types.IO (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e.
                  @ GHC.Types.IO
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBaseControlbExceptT_$cp1MonadBaseControl
                     @ e)
                  (HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBaseControlbExceptT_$cliftBaseWith
                     @ e)
                  (Control.Monad.Trans.Control.$fMonadBaseControlbExceptT_$crestoreM
                     @ GHC.Types.IO
                     @ GHC.Types.IO
                     @ e
                     Control.Monad.Trans.Control.$fMonadBaseControlIOIO) -}
e4271260f8a9a68ff01b4efdfccf0939
  $s$fMonadBaseControlbExceptT_$dMonadBase ::
    Control.Monad.Base.MonadBase GHC.Types.IO GHC.Types.IO
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Control.Monad.Base.$fMonadBaseIOIO -}
cf04ed564be9c2c188a2135ce09e2cca
  $s$fMonadBaseControlbExceptT_$s$fMonadBaseControlbExceptT_$cliftBaseWith ::
    (Control.Monad.Trans.Control.RunInBase
       (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO) GHC.Types.IO
     -> GHC.Types.IO a)
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
  {- Arity: 1, Strictness: <L,C(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ e
                   @ a
                   (ds :: Control.Monad.Trans.Control.RunInBase
                            (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO) GHC.Types.IO
                          -> GHC.Types.IO a) ->
                 Control.Monad.Trans.Control.defaultLiftBaseWith
                   @ (Control.Monad.Trans.Except.ExceptT e)
                   @ GHC.Types.IO
                   @ GHC.Types.IO
                   @ a
                   (Control.Monad.Trans.Control.$fMonadTransControlExceptT @ e)
                   Control.Monad.Trans.Control.$fMonadBaseControlIOIO
                   (\ (ds1 :: Control.Monad.Trans.Control.RunInBaseDefault
                                (Control.Monad.Trans.Except.ExceptT e)
                                GHC.Types.IO
                                GHC.Types.IO) ->
                    ds
                      ds1
                        `cast`
                      (forall (a1 :: <*>_N).
                       <Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a1>_R
                       ->_R (GHC.Types.IO
                               (Sub (Sym (Control.Monad.Trans.Control.D:R:StMExceptTa[0]
                                              <GHC.Types.IO>_N <e>_N <a1>_N))))_R))) -}
91a02c5217b1c92c2c15aa2b63ece675
  $s$fMonadBaseControlbExceptT_$s$fMonadBaseControlbExceptT_$cp1MonadBaseControl ::
    Control.Monad.Base.MonadBase
      GHC.Types.IO (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBasebExceptT -}
f2ac565fea9984290dbea433ac039c6c
  $s$fMonadBaseControlbExceptT_$s$fMonadBasebContT_$cp1MonadBase ::
    GHC.Base.Applicative GHC.Types.IO
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (\ @ r -> GHC.Base.$fApplicativeIO) -}
43de42c54fe76fb0f07215ecce1c5a02
  $s$fMonadBaseControlbExceptT_$s$fMonadBasebContT_$cp3MonadBase ::
    GHC.Base.Monad GHC.Types.IO
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (\ @ r -> GHC.Base.$fMonadIO) -}
928d123edf4de3128b6aa86eea197209
  $s$fMonadBaseControlbExceptT_$s$fMonadBasebExceptT ::
    Control.Monad.Base.MonadBase
      GHC.Types.IO (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e.
                  @ GHC.Types.IO
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBasebContT_$cp1MonadBase
                     @ e)
                  (Control.Monad.Base.$fMonadBasebExceptT_$cp2MonadBase
                     @ GHC.Types.IO
                     @ GHC.Types.IO
                     @ e
                     HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$dMonadBase)
                  (HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBasebContT_$cp3MonadBase
                     @ e)
                  (HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBasebExceptT_$cp4MonadBase
                     @ e)
                  (Control.Monad.Base.$fMonadBasebExceptT_$cliftBase
                     @ GHC.Types.IO
                     @ GHC.Types.IO
                     @ e
                     HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$dMonadBase) -}
065805e11d56755bbb0f5c78aae90478
  $s$fMonadBaseControlbExceptT_$s$fMonadBasebExceptT_$cp4MonadBase ::
    GHC.Base.Monad (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadExceptT -}
4e25f6d1ad4610792ef1c956df936689
  $s$fMonadBaseControlbExceptT_$s$fMonadExceptT ::
    GHC.Base.Monad (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
                  (HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadExceptT_$cp1Monad
                     @ e)
                  (HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadExceptT_$c>>=
                     @ e)
                  (HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadExceptT_$c>>
                     @ e)
                  (Control.Monad.Trans.Except.$fMonadExceptT_$creturn
                     @ GHC.Types.IO
                     @ e
                     GHC.Base.$fMonadIO)
                  (\ @ a (eta :: GHC.Base.String) ->
                   GHC.Base.$fMonadIO_$cfail @ (Data.Either.Either e a) eta)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Base.String>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <e>_N <GHC.Types.IO>_R <a>_N)) -}
1c5f4d3c503ee728cd41e705f0a8938c
  $s$fMonadBaseControlbExceptT_$s$fMonadExceptT_$c>> ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,U))><S,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (k :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (GHC.Types.IO (Data.Either.Either e b))
                   @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
                   (\ (tpl :: GHC.Types.IO (Data.Either.Either e b)) -> tpl)
                     `cast`
                   (<GHC.Types.IO (Data.Either.Either e b)>_R
                    ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <e>_N <GHC.Types.IO>_R <b>_N))
                   (GHC.Base.bindIO
                      @ (Data.Either.Either e a)
                      @ (Data.Either.Either e b)
                      m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a>_N)
                      (\ (a1 :: Data.Either.Either e a)
                         (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       case a1 of wild {
                         Data.Either.Left e1
                         -> (GHC.Base.returnIO
                               @ (Data.Either.Either e b)
                               (Data.Either.Left @ e @ b e1))
                              `cast`
                            (GHC.Types.N:IO[0] <Data.Either.Either e b>_R)
                              eta
                         Data.Either.Right x
                         -> k `cast`
                            (Trans
                                 (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <e>_N <GHC.Types.IO>_R <b>_N)
                                 (GHC.Types.N:IO[0] <Data.Either.Either e b>_R))
                              eta })
                        `cast`
                      (<Data.Either.Either e a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Data.Either.Either e b>_R)))) -}
8e9500fe9e02239a96580ae56c0ef58f
  $s$fMonadBaseControlbExceptT_$s$fMonadExceptT_$c>>= ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> (a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(C1(U(U,U)))><S,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a)
                   (k :: a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (GHC.Types.IO (Data.Either.Either e b))
                   @ (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
                   (\ (tpl :: GHC.Types.IO (Data.Either.Either e b)) -> tpl)
                     `cast`
                   (<GHC.Types.IO (Data.Either.Either e b)>_R
                    ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <e>_N <GHC.Types.IO>_R <b>_N))
                   (GHC.Base.bindIO
                      @ (Data.Either.Either e a)
                      @ (Data.Either.Either e b)
                      m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e>_N <GHC.Types.IO>_R <a>_N)
                      (\ (a1 :: Data.Either.Either e a)
                         (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       case a1 of wild {
                         Data.Either.Left e1
                         -> (GHC.Base.returnIO
                               @ (Data.Either.Either e b)
                               (Data.Either.Left @ e @ b e1))
                              `cast`
                            (GHC.Types.N:IO[0] <Data.Either.Either e b>_R)
                              eta
                         Data.Either.Right x
                         -> (k x)
                              `cast`
                            (Trans
                                 (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <e>_N <GHC.Types.IO>_R <b>_N)
                                 (GHC.Types.N:IO[0] <Data.Either.Either e b>_R))
                              eta })
                        `cast`
                      (<Data.Either.Either e a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Data.Either.Either e b>_R)))) -}
88eafa9507dd3912578649b5cba44bf9
  $s$fMonadBaseControlbExceptT_$s$fMonadExceptT_$cp1Monad ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.AppIO.$s$fApplicativeExceptT -}
29e7d619225f7aa37de38308c8bd7ac7
  $s$fMonadResourceT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Resource.Internal.ResourceT
                       (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                  (Control.Monad.Trans.Resource.Internal.$fMonadResourceT_$cp1Monad
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.AppIO.$s$fMonadResourceT1)
                  (Control.Monad.Trans.Resource.Internal.$fMonadResourceT_$c>>=
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.AppIO.$s$fMonadResourceT1)
                  (Control.Monad.Trans.Resource.Internal.$fMonadResourceT_$c>>
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.AppIO.$s$fMonadResourceT1)
                  (Control.Monad.Trans.Resource.Internal.$fMonadResourceT_$creturn
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.AppIO.$s$fMonadResourceT1)
                  (Control.Monad.Trans.Resource.Internal.$fMonadResourceT_$cfail
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.AppIO.$s$fMonadResourceT1) -}
595808e5341449c489fb580b2cab18e1
  $s$fMonadResourceT1 ::
    GHC.Base.Monad
      (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadExceptT
                   @ [GHC.Types.Char]) -}
0dac7522c2d148f57cf3b432d334b5f0
  $srunConduitRes ::
    Data.Conduit.Internal.Conduit.ConduitM
      ()
      Data.Void.Void
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
      r
    -> Control.Monad.Trans.Except.ExceptT
         GHC.Base.String GHC.Types.IO r
  {- Arity: 1, Strictness: <L,1*C1(U)>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ r
                   (x :: Data.Conduit.Internal.Conduit.ConduitM
                           ()
                           Data.Void.Void
                           (Control.Monad.Trans.Resource.Internal.ResourceT
                              (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                           r) ->
                 Control.Monad.Trans.Resource.runResourceT
                   @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                   @ r
                   HML.FileIO.AppIO.$srunConduitRes1
                   (Data.Conduit.Internal.Conduit.runConduit
                      @ (Control.Monad.Trans.Resource.Internal.ResourceT
                           (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                      @ r
                      HML.FileIO.AppIO.$s$fMonadResourceT
                      x)) -}
136392f334f0be75ebd738bbf371144c
  $srunConduitRes1 ::
    Control.Monad.Trans.Control.MonadBaseControl
      GHC.Types.IO
      (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT
                   @ [GHC.Types.Char]) -}
a41eb55450c8f0ba1f3fca8b301b00dc
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   HML.FileIO.AppIO.$trModule2
                   HML.FileIO.AppIO.$trModule1) -}
62c87962d254893f36330c5c5e2bbcce
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HML.FileIO.AppIO"#) -}
09416495fea2bfd23eb5d5afa805f06e
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "haslearned-0.1.0.0-1MYfuCwSlxlBXzMx3VqeuN"#) -}
6c1de08997d20667fb7953fdd69136a9
  $wconfirmAtom ::
    Data.ByteString.Conversion.From.FromByteString a =>
    (a -> GHC.Types.Bool)
    -> forall b.
       (()
        -> Data.Conduit.Internal.Pipe.Pipe
             Data.ByteString.Internal.ByteString
             Data.ByteString.Internal.ByteString
             Data.ByteString.Internal.ByteString
             ()
             (Control.Monad.Trans.Resource.Internal.ResourceT
                (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
             b)
       -> Data.Conduit.Internal.Pipe.Pipe
            Data.ByteString.Internal.ByteString
            Data.ByteString.Internal.ByteString
            Data.ByteString.Internal.ByteString
            ()
            (Control.Monad.Trans.Resource.Internal.ResourceT
               (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
            b
  {- Arity: 3, Strictness: <L,C(C1(C1(C1(C1(U)))))><L,C(U)><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.ByteString.Conversion.From.FromByteString a)
                   (w1 :: a -> GHC.Types.Bool)
                   @ b
                   (w2 :: ()
                          -> Data.Conduit.Internal.Pipe.Pipe
                               Data.ByteString.Internal.ByteString
                               Data.ByteString.Internal.ByteString
                               Data.ByteString.Internal.ByteString
                               ()
                               (Control.Monad.Trans.Resource.Internal.ResourceT
                                  (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                               b) ->
                 letrec {
                   go :: Data.Conduit.Internal.Pipe.Pipe
                           Data.ByteString.Internal.ByteString
                           Data.ByteString.Internal.ByteString
                           Data.ByteString.Internal.ByteString
                           ()
                           (Control.Monad.Trans.Resource.Internal.ResourceT
                              (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                           b
                   = Data.Conduit.Internal.Pipe.NeedInput
                       @ Data.ByteString.Internal.ByteString
                       @ Data.ByteString.Internal.ByteString
                       @ Data.ByteString.Internal.ByteString
                       @ ()
                       @ (Control.Monad.Trans.Resource.Internal.ResourceT
                            (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                       @ b
                       go1
                       w2
                   lvl21 :: Data.Either.Either
                              [GHC.Types.Char]
                              (Data.Conduit.Internal.Pipe.Pipe
                                 Data.ByteString.Internal.ByteString
                                 Data.ByteString.Internal.ByteString
                                 Data.ByteString.Internal.ByteString
                                 ()
                                 (Control.Monad.Trans.Resource.Internal.ResourceT
                                    (Control.Monad.Trans.Except.ExceptT
                                       GHC.Base.String GHC.Types.IO))
                                 b)
                   = Data.Either.Right
                       @ [GHC.Types.Char]
                       @ (Data.Conduit.Internal.Pipe.Pipe
                            Data.ByteString.Internal.ByteString
                            Data.ByteString.Internal.ByteString
                            Data.ByteString.Internal.ByteString
                            ()
                            (Control.Monad.Trans.Resource.Internal.ResourceT
                               (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                            b)
                       go
                   go1 :: Data.ByteString.Internal.ByteString
                          -> Data.Conduit.Internal.Pipe.Pipe
                               Data.ByteString.Internal.ByteString
                               Data.ByteString.Internal.ByteString
                               Data.ByteString.Internal.ByteString
                               ()
                               (Control.Monad.Trans.Resource.Internal.ResourceT
                                  (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                               b
                     {- Arity: 1, Strictness: <L,U(U,U,U,U)> -}
                   = \ (i1 :: Data.ByteString.Internal.ByteString) ->
                     Data.Conduit.Internal.Pipe.PipeM
                       @ Data.ByteString.Internal.ByteString
                       @ Data.ByteString.Internal.ByteString
                       @ Data.ByteString.Internal.ByteString
                       @ ()
                       @ (Control.Monad.Trans.Resource.Internal.ResourceT
                            (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                       @ b
                       (let {
                          x :: Data.Either.Either GHC.Base.String ()
                          = case w `cast`
                                 (Trans
                                      (Data.ByteString.Conversion.From.N:FromByteString[0] <a>_N)
                                      (Data.Attoparsec.Internal.Types.N:Parser[0]
                                           <Data.ByteString.Internal.ByteString>_N <a>_R))
                                   @ a
                                   (Data.Attoparsec.ByteString.Buffer.buffer i1)
                                     `cast`
                                   (Sub (Sym (Data.Attoparsec.Internal.Types.D:R:StateByteString[0])))
                                   HML.FileIO.AppIO.confirmAtom6
                                     `cast`
                                   (Sym (Data.Attoparsec.Internal.Types.N:Pos[0]))
                                   Data.Attoparsec.Internal.Types.Complete
                                   (Data.Attoparsec.ByteString.Internal.failK @ a)
                                     `cast`
                                   (Sub (Sym (Data.Attoparsec.Internal.Types.D:R:StateByteString[0]))
                                    ->_R <Data.Attoparsec.Internal.Types.Pos
                                          -> Data.Attoparsec.Internal.Types.More
                                          -> [GHC.Base.String]
                                          -> GHC.Base.String
                                          -> Data.Attoparsec.Internal.Types.IResult
                                               Data.ByteString.Internal.ByteString a>_R)
                                   (Data.Attoparsec.ByteString.Internal.successK @ a)
                                     `cast`
                                   (Sub (Sym (Data.Attoparsec.Internal.Types.D:R:StateByteString[0]))
                                    ->_R <Data.Attoparsec.Internal.Types.Pos
                                          -> Data.Attoparsec.Internal.Types.More
                                          -> a
                                          -> Data.Attoparsec.Internal.Types.IResult
                                               Data.ByteString.Internal.ByteString a>_R) of wild {
                              Data.Attoparsec.Internal.Types.Fail ds ds1 err
                              -> case ds1 of wild1 {
                                   [] -> Data.Either.Left @ [GHC.Types.Char] @ () err
                                   : ipv ipv1
                                   -> Data.Either.Left
                                        @ [GHC.Types.Char]
                                        @ ()
                                        (GHC.Base.++
                                           @ GHC.Types.Char
                                           (Data.OldList.intercalate_$spoly_go
                                              @ GHC.Types.Char
                                              ipv
                                              (Data.OldList.prependToAll
                                                 @ [GHC.Types.Char]
                                                 HML.FileIO.AppIO.confirmAtom5
                                                 ipv1))
                                           (GHC.CString.unpackAppendCString# ": "# err)) }
                              Data.Attoparsec.Internal.Types.Partial ipv
                              -> case HML.FileIO.AppIO.confirmAtom4
                                 ret_ty (Data.Either.Either [GHC.Types.Char] ())
                                 of {}
                              Data.Attoparsec.Internal.Types.Done ds a1
                              -> case w1 a1 of wild1 {
                                   GHC.Types.False
                                   -> Data.Either.Left
                                        @ [GHC.Types.Char]
                                        @ ()
                                        (GHC.CString.unpackAppendCString#
                                           "Parser gave unexpected "#
                                           (GHC.CString.unpackAppendCString#
                                              "result "#
                                              (GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.shows6
                                                 (case i1 of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                                                  GHC.Show.showLitString
                                                    (Data.ByteString.Internal.$wunpackAppendCharsLazy
                                                       ww1
                                                       ww2
                                                       ww3
                                                       ww4
                                                       (GHC.Types.[] @ GHC.Types.Char))
                                                    HML.FileIO.AppIO.confirmAtom3 }))))
                                   GHC.Types.True -> HML.FileIO.AppIO.confirmAtom2 } }
                        } in
                        (\ (r :: GHC.IORef.IORef
                                   Control.Monad.Trans.Resource.Internal.ReleaseMap)
                           (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case x of wild {
                           Data.Either.Left e1
                           -> (# eta,
                                 Data.Either.Left
                                   @ [GHC.Types.Char]
                                   @ (Data.Conduit.Internal.Pipe.Pipe
                                        Data.ByteString.Internal.ByteString
                                        Data.ByteString.Internal.ByteString
                                        Data.ByteString.Internal.ByteString
                                        ()
                                        (Control.Monad.Trans.Resource.Internal.ResourceT
                                           (Control.Monad.Trans.Except.ExceptT
                                              GHC.Base.String GHC.Types.IO))
                                        b)
                                   e1 #)
                           Data.Either.Right x1 -> (# eta, lvl21 #) })
                          `cast`
                        (Trans
                             (<GHC.IORef.IORef
                                 Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                              ->_R Trans
                                       (Sym (GHC.Types.N:IO[0]
                                                 <Data.Either.Either
                                                    [GHC.Types.Char]
                                                    (Data.Conduit.Internal.Pipe.Pipe
                                                       Data.ByteString.Internal.ByteString
                                                       Data.ByteString.Internal.ByteString
                                                       Data.ByteString.Internal.ByteString
                                                       ()
                                                       (Control.Monad.Trans.Resource.Internal.ResourceT
                                                          (Control.Monad.Trans.Except.ExceptT
                                                             GHC.Base.String GHC.Types.IO))
                                                       b)>_R))
                                       (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                 <[GHC.Types.Char]>_N
                                                 <GHC.Types.IO>_R
                                                 <Data.Conduit.Internal.Pipe.Pipe
                                                    Data.ByteString.Internal.ByteString
                                                    Data.ByteString.Internal.ByteString
                                                    Data.ByteString.Internal.ByteString
                                                    ()
                                                    (Control.Monad.Trans.Resource.Internal.ResourceT
                                                       (Control.Monad.Trans.Except.ExceptT
                                                          GHC.Base.String GHC.Types.IO))
                                                    b>_N)))
                             (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                       <Control.Monad.Trans.Except.ExceptT
                                          GHC.Base.String GHC.Types.IO>_R
                                       <Data.Conduit.Internal.Pipe.Pipe
                                          Data.ByteString.Internal.ByteString
                                          Data.ByteString.Internal.ByteString
                                          Data.ByteString.Internal.ByteString
                                          ()
                                          (Control.Monad.Trans.Resource.Internal.ResourceT
                                             (Control.Monad.Trans.Except.ExceptT
                                                GHC.Base.String GHC.Types.IO))
                                          b>_N))))
                 } in
                 go) -}
a84e08d52531f43a49be181647819478
  type AppIO =
    Control.Monad.Trans.Resource.Internal.ResourceT
      (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
    :: * -> *
3d75cd84781f5a3279e474a53fc9e71d
  type ConduitAppIO =
    Data.Conduit.Internal.Conduit.ConduitM
      () Data.Void.Void HML.FileIO.AppIO.AppIO ()
6c03ef50ff27ff40abc7a6d045b1c82a
  type Confirmer =
    Data.Conduit.Internal.Conduit.ConduitM
      Data.ByteString.Internal.ByteString
      Data.ByteString.Internal.ByteString
      HML.FileIO.AppIO.AppIO
      ()
5b314dfc65278294a71a3246870515a8
  appIOFail ::
    GHC.Base.String
    -> Data.Conduit.Internal.Conduit.ConduitM
         i o HML.FileIO.AppIO.AppIO ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.AppIO.appIOFail1
                  `cast`
                (forall (i :: <*>_N) (o :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Data.Conduit.Internal.Conduit.N:ConduitM[0]
                               <i>_N
                               <o>_N
                               <Control.Monad.Trans.Resource.Internal.ResourceT
                                  (Control.Monad.Trans.Except.ExceptT
                                     GHC.Base.String GHC.Types.IO)>_N
                               <()>_R)) -}
32697c0d862c6c06c706e69dab08dc57
  appIOFail1 ::
    GHC.Base.String
    -> forall b.
       (()
        -> Data.Conduit.Internal.Pipe.Pipe
             i
             i
             o
             ()
             (Control.Monad.Trans.Resource.Internal.ResourceT
                (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
             b)
       -> Data.Conduit.Internal.Pipe.Pipe
            i
            i
            o
            ()
            (Control.Monad.Trans.Resource.Internal.ResourceT
               (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
            b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ i
                   @ o
                   (e :: GHC.Base.String)
                   @ b
                   (eta :: ()
                           -> Data.Conduit.Internal.Pipe.Pipe
                                i
                                i
                                o
                                ()
                                (Control.Monad.Trans.Resource.Internal.ResourceT
                                   (Control.Monad.Trans.Except.ExceptT
                                      GHC.Base.String GHC.Types.IO))
                                b) ->
                 Data.Conduit.Internal.Pipe.NeedInput
                   @ i
                   @ i
                   @ o
                   @ ()
                   @ (Control.Monad.Trans.Resource.Internal.ResourceT
                        (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                   @ b
                   (\ (i1 :: i) ->
                    Data.Conduit.Internal.Pipe.PipeM
                      @ i
                      @ i
                      @ o
                      @ ()
                      @ (Control.Monad.Trans.Resource.Internal.ResourceT
                           (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                      @ b
                      (\ (r :: GHC.IORef.IORef
                                 Control.Monad.Trans.Resource.Internal.ReleaseMap)
                         (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       (# eta1,
                          Data.Either.Left
                            @ [GHC.Types.Char]
                            @ (Data.Conduit.Internal.Pipe.Pipe
                                 i
                                 i
                                 o
                                 ()
                                 (Control.Monad.Trans.Resource.Internal.ResourceT
                                    (Control.Monad.Trans.Except.ExceptT
                                       GHC.Base.String GHC.Types.IO))
                                 b)
                            e #))
                        `cast`
                      (Trans
                           (<GHC.IORef.IORef
                               Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                            ->_R Trans
                                     (Sym (GHC.Types.N:IO[0]
                                               <Data.Either.Either
                                                  [GHC.Types.Char]
                                                  (Data.Conduit.Internal.Pipe.Pipe
                                                     i
                                                     i
                                                     o
                                                     ()
                                                     (Control.Monad.Trans.Resource.Internal.ResourceT
                                                        (Control.Monad.Trans.Except.ExceptT
                                                           GHC.Base.String GHC.Types.IO))
                                                     b)>_R))
                                     (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                               <[GHC.Types.Char]>_N
                                               <GHC.Types.IO>_R
                                               <Data.Conduit.Internal.Pipe.Pipe
                                                  i
                                                  i
                                                  o
                                                  ()
                                                  (Control.Monad.Trans.Resource.Internal.ResourceT
                                                     (Control.Monad.Trans.Except.ExceptT
                                                        GHC.Base.String GHC.Types.IO))
                                                  b>_N)))
                           (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                     <Control.Monad.Trans.Except.ExceptT
                                        GHC.Base.String GHC.Types.IO>_R
                                     <Data.Conduit.Internal.Pipe.Pipe
                                        i
                                        i
                                        o
                                        ()
                                        (Control.Monad.Trans.Resource.Internal.ResourceT
                                           (Control.Monad.Trans.Except.ExceptT
                                              GHC.Base.String GHC.Types.IO))
                                        b>_N))))
                   eta) -}
e0e7b20c88de79d85e02867e9404f2d3
  confirmAtom ::
    (GHC.Classes.Eq a,
     Data.ByteString.Conversion.From.FromByteString a,
     GHC.Show.Show a) =>
    (a -> GHC.Types.Bool) -> HML.FileIO.AppIO.Confirmer
  {- Arity: 5,
     Strictness: <L,A><L,C(C1(C1(C1(C1(U)))))><L,A><L,C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.AppIO.confirmAtom1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R <Data.ByteString.Conversion.From.FromByteString a>_R
                 ->_R <GHC.Show.Show a>_R
                 ->_R <a -> GHC.Types.Bool>_R
                 ->_R Sym (Data.Conduit.Internal.Conduit.N:ConduitM[0]
                               <Data.ByteString.Internal.ByteString>_N
                               <Data.ByteString.Internal.ByteString>_N
                               <Control.Monad.Trans.Resource.Internal.ResourceT
                                  (Control.Monad.Trans.Except.ExceptT
                                     GHC.Base.String GHC.Types.IO)>_N
                               <()>_R)) -}
9823ba53151f4a05e7a21dbbce1b78b8
  confirmAtom1 ::
    (GHC.Classes.Eq a,
     Data.ByteString.Conversion.From.FromByteString a,
     GHC.Show.Show a) =>
    (a -> GHC.Types.Bool)
    -> forall b.
       (()
        -> Data.Conduit.Internal.Pipe.Pipe
             Data.ByteString.Internal.ByteString
             Data.ByteString.Internal.ByteString
             Data.ByteString.Internal.ByteString
             ()
             (Control.Monad.Trans.Resource.Internal.ResourceT
                (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
             b)
       -> Data.Conduit.Internal.Pipe.Pipe
            Data.ByteString.Internal.ByteString
            Data.ByteString.Internal.ByteString
            Data.ByteString.Internal.ByteString
            ()
            (Control.Monad.Trans.Resource.Internal.ResourceT
               (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
            b
  {- Arity: 5,
     Strictness: <L,A><L,C(C1(C1(C1(C1(U)))))><L,A><L,C(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, True)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: Data.ByteString.Conversion.From.FromByteString a)
                   (w2 :: GHC.Show.Show a)
                   (w3 :: a -> GHC.Types.Bool)
                   @ b
                   (w4 :: ()
                          -> Data.Conduit.Internal.Pipe.Pipe
                               Data.ByteString.Internal.ByteString
                               Data.ByteString.Internal.ByteString
                               Data.ByteString.Internal.ByteString
                               ()
                               (Control.Monad.Trans.Resource.Internal.ResourceT
                                  (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                               b) ->
                 HML.FileIO.AppIO.$wconfirmAtom @ a w1 w3 @ b w4) -}
4f23b1ed405432cf86cf6c109b2559be
  confirmAtom2 :: Data.Either.Either GHC.Base.String ()
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Data.Either.Right
                   @ GHC.Base.String
                   @ ()
                   GHC.Tuple.()) -}
f5327b5d27aed86f238dfdc1d174a629
  confirmAtom3 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1410a85d0c4530c7003641c5efba6f7d
  confirmAtom4 :: Data.Either.Either GHC.Base.String a
  {- Strictness: x -}
457720ad943b4b84a787db4336e34647
  confirmAtom5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " > "#) -}
ccfd550ba7fc2354879af87768a74702
  confirmAtom6 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0#) -}
39b29ce04f3ac8e24de5d5cdbafe56b6
  liftAppIO ::
    Data.Either.Either GHC.Base.String a -> HML.FileIO.AppIO.AppIO a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,U>,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.AppIO.liftAppIO1
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Either.Either GHC.Base.String a>_R
                 ->_R Trans
                          (<GHC.IORef.IORef
                              Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                           ->_R Trans
                                    (Sym (GHC.Types.N:IO[0]
                                              <Data.Either.Either GHC.Base.String a>_R))
                                    (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                              <GHC.Base.String>_N <GHC.Types.IO>_R <a>_N)))
                          (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                    <Control.Monad.Trans.Except.ExceptT
                                       GHC.Base.String GHC.Types.IO>_R
                                    <a>_N))) -}
02e1b53d412886aa13f7b39e4cd72fd0
  liftAppIO1 ::
    Data.Either.Either GHC.Base.String a
    -> GHC.IORef.IORef Control.Monad.Trans.Resource.Internal.ReleaseMap
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either GHC.Base.String a #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   (x :: Data.Either.Either GHC.Base.String a)
                   (eta :: GHC.IORef.IORef
                             Control.Monad.Trans.Resource.Internal.ReleaseMap)
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta1, x #)) -}
2c0b9af9fd937796412dd3d0b0ec2ef4
  maybeToAppIO ::
    GHC.Base.String -> GHC.Base.Maybe a -> HML.FileIO.AppIO.AppIO a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><S,1*U><L,A><S,U>,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.AppIO.maybeToAppIO1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R <GHC.Base.Maybe a>_R
                 ->_R Trans
                          (<GHC.IORef.IORef
                              Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                           ->_R Trans
                                    (Sym (GHC.Types.N:IO[0]
                                              <Data.Either.Either GHC.Base.String a>_R))
                                    (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                              <GHC.Base.String>_N <GHC.Types.IO>_R <a>_N)))
                          (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                    <Control.Monad.Trans.Except.ExceptT
                                       GHC.Base.String GHC.Types.IO>_R
                                    <a>_N))) -}
7a50b90ac330b6238847424dcfc1cf25
  maybeToAppIO1 ::
    GHC.Base.String
    -> GHC.Base.Maybe a
    -> GHC.IORef.IORef Control.Monad.Trans.Resource.Internal.ReleaseMap
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either GHC.Base.String a #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><S,1*U><L,A><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (msg :: GHC.Base.String)
                   (eta :: GHC.Base.Maybe a)
                   (eta1 :: GHC.IORef.IORef
                              Control.Monad.Trans.Resource.Internal.ReleaseMap)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case eta of wild {
                   GHC.Base.Nothing
                   -> (# eta2, Data.Either.Left @ GHC.Base.String @ a msg #)
                   GHC.Base.Just x
                   -> (# eta2, Data.Either.Right @ GHC.Base.String @ a x #) }) -}
3365fa8525d4dc0794fe6c15982ed117
  runAppIO ::
    Data.Conduit.Internal.Conduit.ConduitM
      () Data.Void.Void HML.FileIO.AppIO.AppIO a
    -> GHC.Types.IO (Data.Either.Either GHC.Base.String a)
  {- Arity: 1, Strictness: <L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.AppIO.$srunConduitRes
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Conduit.Internal.Conduit.ConduitM
                    ()
                    Data.Void.Void
                    (Control.Monad.Trans.Resource.Internal.ResourceT
                       (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                    a>_R
                 ->_R Control.Monad.Trans.Except.N:ExceptT[0]
                          <GHC.Base.String>_N <GHC.Types.IO>_R <a>_N) -}
"SPEC/HML.FileIO.AppIO $fApplicativeExceptT @ IO _" [ALWAYS] forall @ e
                                                                    ($dMonad :: GHC.Base.Monad
                                                                                  GHC.Types.IO)
                                                                    ($dFunctor :: GHC.Base.Functor
                                                                                    GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT @ GHC.Types.IO
                                                  @ e
                                                  $dFunctor
                                                  $dMonad
  = HML.FileIO.AppIO.$s$fApplicativeExceptT @ e
"SPEC/HML.FileIO.AppIO $fApplicativeExceptT_$cpure @ IO _" [ALWAYS] forall @ e
                                                                           ($dMonad :: GHC.Base.Monad
                                                                                         GHC.Types.IO)
                                                                           ($dFunctor :: GHC.Base.Functor
                                                                                           GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ GHC.Types.IO
                                                         @ e
                                                         $dFunctor
                                                         $dMonad
  = HML.FileIO.AppIO.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e
"SPEC/HML.FileIO.AppIO $fMonadBaseControlbExceptT @ IO @ IO _" [ALWAYS] forall @ e
                                                                               ($dMonadBaseControl :: Control.Monad.Trans.Control.MonadBaseControl
                                                                                                        GHC.Types.IO
                                                                                                        GHC.Types.IO)
  Control.Monad.Trans.Control.$fMonadBaseControlbExceptT @ GHC.Types.IO
                                                         @ GHC.Types.IO
                                                         @ e
                                                         $dMonadBaseControl
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT @ e
"SPEC/HML.FileIO.AppIO $fMonadBaseControlbExceptT_$cliftBaseWith @ IO @ IO _" [ALWAYS] forall @ e
                                                                                              ($dMonadBaseControl :: Control.Monad.Trans.Control.MonadBaseControl
                                                                                                                       GHC.Types.IO
                                                                                                                       GHC.Types.IO)
  Control.Monad.Trans.Control.$fMonadBaseControlbExceptT_$cliftBaseWith @ GHC.Types.IO
                                                                        @ GHC.Types.IO
                                                                        @ e
                                                                        $dMonadBaseControl
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBaseControlbExceptT_$cliftBaseWith
      @ e
"SPEC/HML.FileIO.AppIO $fMonadBaseControlbExceptT_$cp1MonadBaseControl @ IO @ IO _" [ALWAYS] forall @ e
                                                                                                    ($dMonadBaseControl :: Control.Monad.Trans.Control.MonadBaseControl
                                                                                                                             GHC.Types.IO
                                                                                                                             GHC.Types.IO)
  Control.Monad.Trans.Control.$fMonadBaseControlbExceptT_$cp1MonadBaseControl @ GHC.Types.IO
                                                                              @ GHC.Types.IO
                                                                              @ e
                                                                              $dMonadBaseControl
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBaseControlbExceptT_$cp1MonadBaseControl
      @ e
"SPEC/HML.FileIO.AppIO $fMonadBasebContT_$cp1MonadBase @ IO @ IO _" [ALWAYS] forall @ r
                                                                                    ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                      GHC.Types.IO
                                                                                                      GHC.Types.IO)
  Control.Monad.Base.$fMonadBasebContT_$cp1MonadBase @ GHC.Types.IO
                                                     @ GHC.Types.IO
                                                     @ r
                                                     $dMonadBase
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBasebContT_$cp1MonadBase
      @ r
"SPEC/HML.FileIO.AppIO $fMonadBasebContT_$cp3MonadBase @ IO @ IO _" [ALWAYS] forall @ r
                                                                                    ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                      GHC.Types.IO
                                                                                                      GHC.Types.IO)
  Control.Monad.Base.$fMonadBasebContT_$cp3MonadBase @ GHC.Types.IO
                                                     @ GHC.Types.IO
                                                     @ r
                                                     $dMonadBase
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBasebContT_$cp3MonadBase
      @ r
"SPEC/HML.FileIO.AppIO $fMonadBasebExceptT @ IO @ IO _" [ALWAYS] forall @ e
                                                                        ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                          GHC.Types.IO
                                                                                          GHC.Types.IO)
  Control.Monad.Base.$fMonadBasebExceptT @ GHC.Types.IO
                                         @ GHC.Types.IO
                                         @ e
                                         $dMonadBase
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBasebExceptT
      @ e
"SPEC/HML.FileIO.AppIO $fMonadBasebExceptT_$cp4MonadBase @ IO @ IO _" [ALWAYS] forall @ e
                                                                                      ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                        GHC.Types.IO
                                                                                                        GHC.Types.IO)
  Control.Monad.Base.$fMonadBasebExceptT_$cp4MonadBase @ GHC.Types.IO
                                                       @ GHC.Types.IO
                                                       @ e
                                                       $dMonadBase
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadBasebExceptT_$cp4MonadBase
      @ e
"SPEC/HML.FileIO.AppIO $fMonadExceptT @ IO _" [ALWAYS] forall @ e
                                                              ($dMonad :: GHC.Base.Monad
                                                                            GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT @ GHC.Types.IO
                                            @ e
                                            $dMonad
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadExceptT
      @ e
"SPEC/HML.FileIO.AppIO $fMonadExceptT_$c>> @ IO _" [ALWAYS] forall @ e
                                                                   ($dMonad :: GHC.Base.Monad
                                                                                 GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT_$c>> @ GHC.Types.IO
                                                 @ e
                                                 $dMonad
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadExceptT_$c>>
      @ e
"SPEC/HML.FileIO.AppIO $fMonadExceptT_$c>>= @ IO _" [ALWAYS] forall @ e
                                                                    ($dMonad :: GHC.Base.Monad
                                                                                  GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT_$c>>= @ GHC.Types.IO
                                                  @ e
                                                  $dMonad
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadExceptT_$c>>=
      @ e
"SPEC/HML.FileIO.AppIO $fMonadExceptT_$cp1Monad @ IO _" [ALWAYS] forall @ e
                                                                        ($dMonad :: GHC.Base.Monad
                                                                                      GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT_$cp1Monad @ GHC.Types.IO
                                                      @ e
                                                      $dMonad
  = HML.FileIO.AppIO.$s$fMonadBaseControlbExceptT_$s$fMonadExceptT_$cp1Monad
      @ e
"SPEC/HML.FileIO.AppIO $fMonadResourceT @ (ExceptT String IO)" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                GHC.Base.String
                                                                                                GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadResourceT @ (Control.Monad.Trans.Except.ExceptT
                                                              GHC.Base.String GHC.Types.IO)
                                                         $dMonad
  = HML.FileIO.AppIO.$s$fMonadResourceT
"SPEC/HML.FileIO.AppIO runConduitRes @ (ExceptT String IO) _" [ALWAYS] forall @ r
                                                                              ($dMonadBaseControl :: Control.Monad.Trans.Control.MonadBaseControl
                                                                                                       GHC.Types.IO
                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                          GHC.Base.String
                                                                                                          GHC.Types.IO))
  Data.Conduit.runConduitRes @ (Control.Monad.Trans.Except.ExceptT
                                  GHC.Base.String GHC.Types.IO)
                             @ r
                             $dMonadBaseControl
  = HML.FileIO.AppIO.$srunConduitRes @ r
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

