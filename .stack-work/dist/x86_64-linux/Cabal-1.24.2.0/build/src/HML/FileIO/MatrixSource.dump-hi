
==================== FINAL INTERFACE ====================
2017-11-20 04:54:06.926521 UTC

interface haslearned-0.1.0.0-1MYfuCwSlxlBXzMx3VqeuN:HML.FileIO.MatrixSource 8002
  interface hash: d3927860b67738934fc3d2c19bd67bc6
  ABI hash: b1f74c257e8d1c873530d41cc267ae19
  export-list hash: 960fd45111c182a56013c6ec63b3b965
  orphan hash: fc272b50099431f75912c7d700352c93
  flag hash: f03ac6ae1b69e572c5f54bc4af3dc5a9
  sig of: Nothing
  used TH splices: False
  where
exports:
  HML.FileIO.MatrixSource.confirmMatrixHeader
  HML.FileIO.MatrixSource.matrixDoubleSource
  HML.FileIO.MatrixSource.poolMatrix
  HML.FileIO.MatrixSource.poolMatrixDouble
  HML.FileIO.MatrixSource.ByteStringToMatrix{HML.FileIO.MatrixSource.ByteStringToMatrix context suggestion transform}
module dependencies: HML.Aux HML.FileIO.AppIO
                     HML.FileIO.MatrixHeader HML.Types.Constants
                     HML.Types.DoubleToBinary HML.Types.PosInt HML.Types.TypeName
package dependencies: QuickCheck-2.9.2@QuickCheck-2.9.2-LvlomhGMxrFBkX1zwiWpQu
                      array-0.5.1.1@array-0.5.1.1
                      attoparsec-0.13.1.0@attoparsec-0.13.1.0-3ql4hcH9pGfBAlE21oqFTQ
                      base-4.9.1.0
                      base16-bytestring-0.1.1.6@base16-bytestring-0.1.1.6-4E2p94lTx8gIceMhu8Kl9o
                      base64-bytestring-1.0.0.1@base64-bytestring-1.0.0.1-4O9TExPPz6eI82Yj7L4SIj
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      bytestring-conversion-0.3.1@bytestring-conversion-0.3.1-KSK6l7QmbIf1TbIBILuJUV
                      case-insensitive-1.2.0.10@case-insensitive-1.2.0.10-1D5OUKQ7UrJ7IpOe0di4Un
                      cereal-0.5.4.0@cereal-0.5.4.0-BsAGxfp8yAs3CiRo2E875e
                      chunked-data-0.3.0@chunked-data-0.3.0-OOunTfArGE2y1nE8RKgW4
                      conduit-1.2.12.1@conduit-1.2.12.1-CTYKTJmwFo81r4LrAKDD8i
                      conduit-combinators-1.1.1@conduit-combinators-1.1.1-GtFbL9AxEDH5Bi4dHJqDcv
                      conduit-extra-1.1.17@conduit-extra-1.1.17-LHyPtC0nGlzDcgVxOcd4h4
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 directory-1.3.0.0@directory-1.3.0.0
                      double-conversion-2.0.2.0@double-conversion-2.0.2.0-Ls1AZoWRK0TKpzR8XpTsSD
                      exceptions-0.8.3@exceptions-0.8.3-ADEDRATtUrMK1JW4zMQ9U
                      filepath-1.4.1.1@filepath-1.4.1.1
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj
                      integer-gmp-1.0.0.1
                      integer-logarithms-1.0.2@integer-logarithms-1.0.2-92lMiWV9mmYAwfMEYgfQ0D
                      lifted-base-0.2.3.11@lifted-base-0.2.3.11-Ei0JSPdt7KOCD2HIA5jFqV
                      mmorph-1.0.9@mmorph-1.0.9-5bASEvmIkr5CpdAYXwPsn0
                      monad-control-1.0.2.2@monad-control-1.0.2.2-1Ci8dYJ8Tb7E3HTcTqOb8l
                      mono-traversable-1.0.4.0@mono-traversable-1.0.4.0-4NjleFtgjZEBUffX1jBk6F
                      mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      mwc-random-0.13.6.0@mwc-random-0.13.6.0-FYg9HqO0pqB8vcniiPVzVy
                      pretty-1.1.3.3@pretty-1.1.3.3
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      resourcet-1.1.9@resourcet-1.1.9-L2BUQrxWZMwDiwhcuyPuNi
                      scientific-0.3.5.2@scientific-0.3.5.2-FM2NdrNTcdbCDq9wuNnhIA
                      split-0.2.3.2@split-0.2.3.2-CJl40zTyCIV16Pr60nb7CT
                      stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve
                      streaming-commons-0.1.17@streaming-commons-0.1.17-6xuIA5RXrs65yyeq3HWIWP
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      tf-random-0.5@tf-random-0.5-CJZw1ZWS5MOJlR60HqKEZL
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      transformers-base-0.4.4@transformers-base-0.4.4-GKSs0LKukAL8ymq2naFmrH
                      unix-2.7.2.1@unix-2.7.2.1
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC
                      vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ
                      vector-algorithms-0.7.0.1@vector-algorithms-0.7.0.1-1qlx0Hst1Fo5WZd0lT7Iw1
orphans: attoparsec-0.13.1.0@attoparsec-0.13.1.0-3ql4hcH9pGfBAlE21oqFTQ:Data.Attoparsec.ByteString.Char8
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         haslearned-0.1.0.0-1MYfuCwSlxlBXzMx3VqeuN:HML.Types.PosInt
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.CG
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Element
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Util
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Vector
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Numeric.Matrix
         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Numeric.Vector
         stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve:Control.Monad.STM
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Fusion.Bundle
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
family instance modules: attoparsec-0.13.1.0@attoparsec-0.13.1.0-3ql4hcH9pGfBAlE21oqFTQ:Data.Attoparsec.Internal.Types
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         conduit-1.2.12.1@conduit-1.2.12.1-CTYKTJmwFo81r4LrAKDD8i:Data.Conduit.Internal.Conduit
                         conduit-1.2.12.1@conduit-1.2.12.1-CTYKTJmwFo81r4LrAKDD8i:Data.Conduit.Internal.Pipe
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Devel
                         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Matrix
                         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Modular
                         hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Numeric
                         monad-control-1.0.2.2@monad-control-1.0.2.2-1Ci8dYJ8Tb7E3HTcTqOb8l:Control.Monad.Trans.Control
                         mono-traversable-1.0.4.0@mono-traversable-1.0.4.0-4NjleFtgjZEBUffX1jBk6F:Data.MonoTraversable
                         mono-traversable-1.0.4.0@mono-traversable-1.0.4.0-4NjleFtgjZEBUffX1jBk6F:Data.NonNull
                         mono-traversable-1.0.4.0@mono-traversable-1.0.4.0-4NjleFtgjZEBUffX1jBk6F:Data.Sequences
                         mwc-random-0.13.6.0@mwc-random-0.13.6.0-FYg9HqO0pqB8vcniiPVzVy:System.Random.MWC
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Data.Primitive.Array
                         resourcet-1.1.9@resourcet-1.1.9-L2BUQrxWZMwDiwhcuyPuNi:Control.Monad.Trans.Resource.Internal
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashSet
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Primitive
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Storable
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed.Base
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Either 20b09ef8d0a5b74fdec011c40c1587f5
import  -/  base-4.9.1.0:Foreign.Storable 085c8d7f42ceec1dbb4e818f06339b9d
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.IO eb504c57b397cf133849f8586f15dafb
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString 43e99fdac51908da414a28958688da64
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Internal 89cda42ec946d9d6577dd41ab95d523e
import  -/  cereal-0.5.4.0@cereal-0.5.4.0-BsAGxfp8yAs3CiRo2E875e:Data.Serialize.Get 9fc275e93feca7102924cbf0903857f0
import  -/  conduit-1.2.12.1@conduit-1.2.12.1-CTYKTJmwFo81r4LrAKDD8i:Data.Conduit 8d7ec43e22522a4dafe1e40081e3bcee
import  -/  conduit-1.2.12.1@conduit-1.2.12.1-CTYKTJmwFo81r4LrAKDD8i:Data.Conduit.Internal.Conduit cb2416e4318f4105196b90a1a4c4b9f2
import  -/  conduit-combinators-1.1.1@conduit-combinators-1.1.1-GtFbL9AxEDH5Bi4dHJqDcv:Conduit 4b8c71dec647b12e304799221bd3ba2e
import  -/  conduit-combinators-1.1.1@conduit-combinators-1.1.1-GtFbL9AxEDH5Bi4dHJqDcv:Data.Conduit.Combinators 47fdc740819fa4aa37b3877f8a6d0a66
import  -/  conduit-combinators-1.1.1@conduit-combinators-1.1.1-GtFbL9AxEDH5Bi4dHJqDcv:Data.Conduit.Combinators.Unqualified ad729553ca387c95a05a93841e33ba6e
import  -/  filepath-1.4.1.1@filepath-1.4.1.1:System.FilePath a3d1d13ac7dd86705b5dfaf58a5c0b9e
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  HML.Aux db2817fb9f55bb999c86701baf3da082
  exports: b865416e77cf23e87cedb9d2cf5fcec5
  doubleSize dcea786ff13a820da75e08cbae7e466b
  errorContext aa0583d31fab01adf3a6bb6dafc1b67c
import  -/  HML.FileIO.AppIO 996f0663a9234630e6f09df1c28d64d3
  exports: ec1bc10e02b198719ccbde6835fb6842
  AppIO a84e08d52531f43a49be181647819478
  Confirmer 6c03ef50ff27ff40abc7a6d045b1c82a
  appIOFail 5b314dfc65278294a71a3246870515a8
  confirmAtom e0e7b20c88de79d85e02867e9404f2d3
  liftAppIO 39b29ce04f3ac8e24de5d5cdbafe56b6
import  -/  HML.FileIO.MatrixHeader 55866bc7e98e7ba1f7fa5af73c65820d
  exports: 9663010371bc593925810eed4c69845b
  MatrixHeader b2ea802841815117022cbfe9bdee05b2
  cols cd6dc4d4f8ebaed77924c4f5a05d8aa3
  compatibleHeaders 558d969fb30f9eb44da6c4bac70c6070
  dataType 6f0e2169ab96270f94c4a2b82a116f75
  rows 0a7622fee23ef943c3170e1f3235fa5a
import  -/  HML.Types.Constants eea9f8132a6546f4e492c01a83dc9c00
  exports: 878d4cbaaafe0710ed0f06c4eb6b07e8
  binarySeparator 1226922354e43f41d5817e4e75e638e9
  separator 0490423fbf54a372c78ae6c93cd9b65d
import  -/  HML.Types.DoubleToBinary a30e98382d43069f84888539b0421668
  exports: f6557fc8189fc77b42cbe085c4c819fd
  doubleFromBinary 92ec29f6a62b6f1ebdcdf25b76c89e95
import  -/  HML.Types.PosInt e76284e9d561a007ee931c212ba10a01
  exports: cb9dc14fda9b216a29a6ff1f144bd6c0
  PosInt 5108cb4455de278e3ba122e1d7edf8ea
  getPosInt 0d8ac78274d442f7a8a44a7e0f8db2a0
import  -/  HML.Types.TypeName 860c931b806fae13090ea4b89f4273e4
  exports: 2254311b48ddd492ba327dab8c37167b
  DBL a4fcf072a7d785f99ca8a04647854ecd
import  -/  hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Element 173b8c4c738a67dfbd30989e88c1b91b
import  -/  hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Internal.Matrix 53638184b736d49afc503f161ceef1e2
import  -/  hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Numeric.LinearAlgebra ee42d53f4ea01fd23be32d73fe10df7b
import  -/  hmatrix-0.18.0.0@hmatrix-0.18.0.0-LGKm3fIBRZO9Qs5hltonpj:Numeric.LinearAlgebra.Data 9ebd9664f9d22e6d69a44fbe0dc7ae55
0cbfe12fb4bb6c0892d1e38d853459a2
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e1.
                  @ (Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO)
                  (HML.FileIO.MatrixSource.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cp1Applicative
                     @ e1)
                  (HML.FileIO.MatrixSource.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e1)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ GHC.Types.IO
                     @ e1
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c*>
                     @ GHC.Types.IO
                     @ e1
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*
                     @ GHC.Types.IO
                     @ e1
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO) -}
53ef06f94768664cf4ac48ba7ed3b5b8
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cp1Applicative ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.MatrixSource.$s$fApplicativeExceptT_$s$fFunctorExceptT -}
8bce70f848c35ebde2d452def81c05f3
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e1 @ a (a1 :: a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (GHC.Types.IO (Data.Either.Either e1 a))
                   @ (Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO a)
                   (\ (tpl :: GHC.Types.IO (Data.Either.Either e1 a)) -> tpl)
                     `cast`
                   (<GHC.Types.IO (Data.Either.Either e1 a)>_R
                    ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <e1>_N <GHC.Types.IO>_R <a>_N))
                   (GHC.Base.returnIO
                      @ (Data.Either.Either e1 a)
                      (Data.Either.Right @ e1 @ a a1))) -}
a47b5d85bbac45145a6f2d0824835e7b
  $s$fApplicativeExceptT_$s$fFunctorExceptT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e1.
                  @ (Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO)
                  (HML.FileIO.MatrixSource.$s$fApplicativeExceptT_$s$fFunctorExceptT_$cfmap
                     @ e1)
                  (Control.Monad.Trans.Except.$fFunctorExceptT_$c<$
                     @ GHC.Types.IO
                     @ e1
                     GHC.Base.$fFunctorIO) -}
bf908a9d4c2cb7ce2ede99d80917c193
  $s$fApplicativeExceptT_$s$fFunctorExceptT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(S(SL)),1*C1(U(U,1*U))><S,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e1
                   @ a
                   @ b
                   (f :: a -> b)
                   (eta :: Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO a)
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (GHC.Base.$fFunctorIO_$cfmap
                    @ (Data.Either.Either e1 a)
                    @ (Data.Either.Either e1 b)
                    (Data.Either.$fApplicativeEither_$cfmap @ e1 @ a @ b f)
                    eta
                      `cast`
                    (Control.Monad.Trans.Except.N:ExceptT[0]
                         <e1>_N <GHC.Types.IO>_R <a>_N))
                   `cast`
                 (GHC.Types.N:IO[0] <Data.Either.Either e1 b>_R)
                   eta1)
                  `cast`
                (forall (e1 :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO a>_R
                 ->_R Trans
                          (Sym (GHC.Types.N:IO[0] <Data.Either.Either e1 b>_R))
                          (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                    <e1>_N <GHC.Types.IO>_R <b>_N))) -}
300523a84b343d02a5b212078c1dadda
  $s$fApplicativeResourceT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Resource.Internal.ResourceT
                       (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                  HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$s$fApplicativeResourceT_$cp1Applicative
                  HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$s$fApplicativeResourceT_$cpure
                  (Control.Monad.Trans.Resource.Internal.$fApplicativeResourceT_$c<*>
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$dApplicative)
                  (Control.Monad.Trans.Resource.Internal.$fApplicativeResourceT_$c*>
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$dApplicative)
                  (Control.Monad.Trans.Resource.Internal.$fApplicativeResourceT_$c<*
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$dApplicative) -}
290004f4bad0ebb67efb17bcc0e6ccfb
  $s$fApplicativeResourceT_$dApplicative ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (HML.FileIO.MatrixSource.$s$fApplicativeExceptT
                   @ [GHC.Types.Char]) -}
e16936e0eee51a8b5c529702c3d64561
  $s$fApplicativeResourceT_$dFunctor ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (HML.FileIO.MatrixSource.$s$fApplicativeExceptT_$s$fFunctorExceptT
                   @ [GHC.Types.Char]) -}
f0827af75d333e02953837b333ad6e38
  $s$fApplicativeResourceT_$s$fApplicativeResourceT_$cp1Applicative ::
    GHC.Base.Functor
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$s$fFunctorResourceT -}
ae6e7bcc8ad582878e2c56131e298798
  $s$fApplicativeResourceT_$s$fApplicativeResourceT_$cpure ::
    a
    -> Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO) a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (eta :: a) ->
                 let {
                   x :: Control.Monad.Trans.Except.ExceptT
                          GHC.Base.String GHC.Types.IO a
                   = GHC.Base.$
                       @ 'GHC.Types.PtrRepLifted
                       @ (GHC.Types.IO (Data.Either.Either [GHC.Types.Char] a))
                       @ (Control.Monad.Trans.Except.ExceptT
                            [GHC.Types.Char] GHC.Types.IO a)
                       (\ (tpl :: GHC.Types.IO (Data.Either.Either [GHC.Types.Char] a)) ->
                        tpl)
                         `cast`
                       (<GHC.Types.IO (Data.Either.Either [GHC.Types.Char] a)>_R
                        ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <[GHC.Types.Char]>_N <GHC.Types.IO>_R <a>_N))
                       (GHC.Base.returnIO
                          @ (Data.Either.Either [GHC.Types.Char] a)
                          (Data.Either.Right @ [GHC.Types.Char] @ a eta))
                 } in
                 (\ (ds2 :: GHC.IORef.IORef
                              Control.Monad.Trans.Resource.Internal.ReleaseMap) ->
                  x)
                   `cast`
                 (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                           <Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO>_R
                           <a>_N))) -}
53d327dd564b35d0c37ac250b6998e2f
  $s$fApplicativeResourceT_$s$fFunctorResourceT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Resource.Internal.ResourceT
                       (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                  (Control.Monad.Trans.Resource.Internal.$fFunctorResourceT_$cfmap
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$dFunctor)
                  (Control.Monad.Trans.Resource.Internal.$fFunctorResourceT_$c<$
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$dFunctor) -}
8c388752710cc8e27a19e529d8cf82f0
  $s$fMonadBasebContT_$cp1MonadBase ::
    GHC.Base.Applicative GHC.Types.IO
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (\ @ r -> GHC.Base.$fApplicativeIO) -}
0bf99265492bd67f46fd3a195cf6ba42
  $s$fMonadBasebContT_$cp3MonadBase :: GHC.Base.Monad GHC.Types.IO
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (\ @ r -> GHC.Base.$fMonadIO) -}
4b27d580759ed3d0b8cd821e1116e731
  $s$fMonadBasebExceptT ::
    Control.Monad.Base.MonadBase
      GHC.Types.IO (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e1.
                  @ GHC.Types.IO
                  @ (Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO)
                  (HML.FileIO.MatrixSource.$s$fMonadBasebContT_$cp1MonadBase @ e1)
                  (Control.Monad.Base.$fMonadBasebExceptT_$cp2MonadBase
                     @ GHC.Types.IO
                     @ GHC.Types.IO
                     @ e1
                     Control.Monad.Base.$fMonadBaseIOIO)
                  (HML.FileIO.MatrixSource.$s$fMonadBasebContT_$cp3MonadBase @ e1)
                  (HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadThrowExceptT_$cp1MonadThrow
                     @ e1)
                  (Control.Monad.Base.$fMonadBasebExceptT_$cliftBase
                     @ GHC.Types.IO
                     @ GHC.Types.IO
                     @ e1
                     Control.Monad.Base.$fMonadBaseIOIO) -}
9c34a0d9906badc7364020586b3c23e2
  $s$fMonadBasebExceptT_$dMonad :: GHC.Base.Monad GHC.Types.IO
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) GHC.Base.$fMonadIO -}
1b2c7c44896de8fed2b96f5a25c1f994
  $s$fMonadBasebExceptT_$s$fMonadExceptT ::
    GHC.Base.Monad (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e1.
                  @ (Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO)
                  (HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadExceptT_$cp1Monad
                     @ e1)
                  (HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadExceptT_$c>>=
                     @ e1)
                  (HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadExceptT_$c>>
                     @ e1)
                  (Control.Monad.Trans.Except.$fMonadExceptT_$creturn
                     @ GHC.Types.IO
                     @ e1
                     HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$dMonad)
                  (\ @ a (eta :: GHC.Base.String) ->
                   GHC.Base.$fMonadIO_$cfail @ (Data.Either.Either e1 a) eta)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Base.String>_R
                   ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <e1>_N <GHC.Types.IO>_R <a>_N)) -}
3228a9132c665b4290b410c199cbc27d
  $s$fMonadBasebExceptT_$s$fMonadExceptT_$c>> ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(U(U,U))><S,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e1
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO a)
                   (k :: Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (GHC.Types.IO (Data.Either.Either e1 b))
                   @ (Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO b)
                   (\ (tpl :: GHC.Types.IO (Data.Either.Either e1 b)) -> tpl)
                     `cast`
                   (<GHC.Types.IO (Data.Either.Either e1 b)>_R
                    ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <e1>_N <GHC.Types.IO>_R <b>_N))
                   (GHC.Base.bindIO
                      @ (Data.Either.Either e1 a)
                      @ (Data.Either.Either e1 b)
                      m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e1>_N <GHC.Types.IO>_R <a>_N)
                      (\ (a1 :: Data.Either.Either e1 a)
                         (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       case a1 of wild {
                         Data.Either.Left e2
                         -> (GHC.Base.returnIO
                               @ (Data.Either.Either e1 b)
                               (Data.Either.Left @ e1 @ b e2))
                              `cast`
                            (GHC.Types.N:IO[0] <Data.Either.Either e1 b>_R)
                              eta
                         Data.Either.Right x
                         -> k `cast`
                            (Trans
                                 (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <e1>_N <GHC.Types.IO>_R <b>_N)
                                 (GHC.Types.N:IO[0] <Data.Either.Either e1 b>_R))
                              eta })
                        `cast`
                      (<Data.Either.Either e1 a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Data.Either.Either e1 b>_R)))) -}
20548228c4a75d48fd6636c30ab049ea
  $s$fMonadBasebExceptT_$s$fMonadExceptT_$c>>= ::
    Control.Monad.Trans.Except.ExceptT e GHC.Types.IO a
    -> (a -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b)
    -> Control.Monad.Trans.Except.ExceptT e GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SS)),1*C1(U(U,1*U))><L,1*C1(C1(U(U,U)))><S,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e1
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO a)
                   (k :: a -> Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (GHC.Types.IO (Data.Either.Either e1 b))
                   @ (Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO b)
                   (\ (tpl :: GHC.Types.IO (Data.Either.Either e1 b)) -> tpl)
                     `cast`
                   (<GHC.Types.IO (Data.Either.Either e1 b)>_R
                    ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <e1>_N <GHC.Types.IO>_R <b>_N))
                   (GHC.Base.bindIO
                      @ (Data.Either.Either e1 a)
                      @ (Data.Either.Either e1 b)
                      m1
                        `cast`
                      (Control.Monad.Trans.Except.N:ExceptT[0]
                           <e1>_N <GHC.Types.IO>_R <a>_N)
                      (\ (a1 :: Data.Either.Either e1 a)
                         (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       case a1 of wild {
                         Data.Either.Left e2
                         -> (GHC.Base.returnIO
                               @ (Data.Either.Either e1 b)
                               (Data.Either.Left @ e1 @ b e2))
                              `cast`
                            (GHC.Types.N:IO[0] <Data.Either.Either e1 b>_R)
                              eta
                         Data.Either.Right x
                         -> (k x)
                              `cast`
                            (Trans
                                 (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <e1>_N <GHC.Types.IO>_R <b>_N)
                                 (GHC.Types.N:IO[0] <Data.Either.Either e1 b>_R))
                              eta })
                        `cast`
                      (<Data.Either.Either e1 a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Data.Either.Either e1 b>_R)))) -}
37288d9e8b68b826b6c2f1bdbc618945
  $s$fMonadBasebExceptT_$s$fMonadExceptT_$cp1Monad ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.MatrixSource.$s$fApplicativeExceptT -}
1e831da470e780000ee00a18dcc9ec63
  $s$fMonadBasebExceptT_$s$fMonadThrowExceptT_$cp1MonadThrow ::
    GHC.Base.Monad (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadExceptT -}
06b5b5ae134b6e011d7dbc4242807797
  $s$fMonadBasebResourceT ::
    Control.Monad.Base.MonadBase
      GHC.Types.IO
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.IO
                  @ (Control.Monad.Trans.Resource.Internal.ResourceT
                       (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                  (HML.FileIO.MatrixSource.$s$fMonadBasebContT_$cp1MonadBase
                     @ [GHC.Types.Char])
                  HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadBasebResourceT_$cp2MonadBase
                  (HML.FileIO.MatrixSource.$s$fMonadBasebContT_$cp3MonadBase
                     @ [GHC.Types.Char])
                  HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadIOResourceT_$cp1MonadIO
                  HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadBasebResourceT_$cliftBase -}
1d886bac3e2d53336fabad50aa3e6384
  $s$fMonadBasebResourceT_$dMonad ::
    GHC.Base.Monad
      (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadExceptT
                   @ [GHC.Types.Char]) -}
e2bbfb1c5f443510dd8093ecdc5a8329
  $s$fMonadBasebResourceT_$s$fMonadBasebResourceT_$cliftBase ::
    GHC.Types.IO α
    -> Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO) α
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SL)),1*C1(U(U,U))><L,A><S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ α (eta :: GHC.Types.IO α) ->
                 let {
                   eta1 :: Control.Monad.Trans.Except.ExceptT
                             GHC.Base.String GHC.Types.IO α
                   = Control.Monad.Base.$fMonadBasebExceptT_$cliftBase
                       @ GHC.Types.IO
                       @ GHC.Types.IO
                       @ [GHC.Types.Char]
                       Control.Monad.Base.$fMonadBaseIOIO
                       @ α
                       eta
                 } in
                 (\ (ds2 :: GHC.IORef.IORef
                              Control.Monad.Trans.Resource.Internal.ReleaseMap) ->
                  eta1)
                   `cast`
                 (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                           <Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO>_R
                           <α>_N))) -}
5577f531f6791c41d6ed8cfc21437726
  $s$fMonadBasebResourceT_$s$fMonadBasebResourceT_$cp2MonadBase ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.MatrixSource.$s$fApplicativeResourceT -}
3db0eb7297e426678df73bbee7a0bd02
  $s$fMonadBasebResourceT_$s$fMonadIOResourceT_$cp1MonadIO ::
    GHC.Base.Monad
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadResourceT -}
6ccdcf599203926340424b98dad1a143
  $s$fMonadBasebResourceT_$s$fMonadResourceT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Resource.Internal.ResourceT
                       (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                  HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadBasebResourceT_$cp2MonadBase
                  (Control.Monad.Trans.Resource.Internal.$fMonadResourceT_$c>>=
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$dMonad)
                  (Control.Monad.Trans.Resource.Internal.$fMonadResourceT_$c>>
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$dMonad)
                  HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$s$fApplicativeResourceT_$cpure
                  HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadResourceT_$cfail -}
2b27bda5b8136af9318b678ce6cebb1b
  $s$fMonadBasebResourceT_$s$fMonadResourceT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO) a
  {- Arity: 1, Strictness: <B,U>x,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (eta :: GHC.Base.String) ->
                 Control.Monad.Trans.Resource.Internal.$fMonadResourceT1
                   @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                   @ a
                   HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$dMonad
                   eta) -}
9b3e30b2823683526b170d8aa8bc16cc
  $s$fMonadIOExceptT ::
    Control.Monad.IO.Class.MonadIO
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e1.
                  @ (Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO)
                  (HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadThrowExceptT_$cp1MonadThrow
                     @ e1)
                  (\ @ a
                     (eta :: GHC.Types.IO a)
                     (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                   (GHC.Base.$fFunctorIO_$cfmap
                      @ a
                      @ (Data.Either.Either e1 a)
                      (Data.Either.Right @ e1 @ a)
                      (GHC.Base.id @ (GHC.Types.IO a) eta))
                     `cast`
                   (GHC.Types.N:IO[0] <Data.Either.Either e1 a>_R)
                     eta1)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R Trans
                            (Sym (GHC.Types.N:IO[0] <Data.Either.Either e1 a>_R))
                            (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <e1>_N <GHC.Types.IO>_R <a>_N))) -}
6766d773d1c8b1356fcf660e11885b0a
  $s$fMonadIOResourceT ::
    Control.Monad.IO.Class.MonadIO
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Resource.Internal.ResourceT
                       (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                  HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadIOResourceT_$cp1MonadIO
                  HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadBasebResourceT_$cliftBase -}
b04deb604468709bc1dc2943852b197d
  $s$fMonadResourceResourceT ::
    Control.Monad.Trans.Resource.Internal.MonadResource
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Resource.Internal.ResourceT
                       (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                  HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadResourceResourceT_$cp1MonadResource
                  HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadResourceResourceT_$cp2MonadResource
                  HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadBasebResourceT_$cp2MonadBase
                  HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadResourceResourceT_$cp4MonadResource
                  (Control.Monad.Trans.Resource.Internal.$fMonadResourceResourceT_$cliftResourceT
                     @ (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
                     HML.FileIO.MatrixSource.$s$fMonadResourceResourceT3
                     HML.FileIO.MatrixSource.$s$fMonadResourceResourceT2
                     HML.FileIO.MatrixSource.$s$fMonadResourceResourceT1
                     HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$dApplicative) -}
610d1a179c48c349ae2ddbba5d16b461
  $s$fMonadResourceResourceT1 ::
    Control.Monad.IO.Class.MonadIO
      (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (HML.FileIO.MatrixSource.$s$fMonadIOExceptT @ [GHC.Types.Char]) -}
3e276bfa5b8a037357e03b9310499ccb
  $s$fMonadResourceResourceT2 ::
    Control.Monad.Base.MonadBase
      GHC.Types.IO
      (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (HML.FileIO.MatrixSource.$s$fMonadBasebExceptT
                   @ [GHC.Types.Char]) -}
8e56674fdd6f3ab782927d68507a34fe
  $s$fMonadResourceResourceT3 ::
    Control.Monad.Catch.MonadThrow
      (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadThrowExceptT
                   @ [GHC.Types.Char]) -}
b561e1dfd97ded7013d8614752ff8b54
  $s$fMonadResourceResourceT_$s$fMonadResourceResourceT_$cp1MonadResource ::
    Control.Monad.Catch.MonadThrow
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadThrowResourceT -}
2c3a61381d494b8368ee357401eb8b3c
  $s$fMonadResourceResourceT_$s$fMonadResourceResourceT_$cp2MonadResource ::
    Control.Monad.IO.Class.MonadIO
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.MatrixSource.$s$fMonadIOResourceT -}
25f9944f048e3b64a69d4a933a0c5e62
  $s$fMonadResourceResourceT_$s$fMonadResourceResourceT_$cp4MonadResource ::
    Control.Monad.Base.MonadBase
      GHC.Types.IO
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.MatrixSource.$s$fMonadBasebResourceT -}
9a5ff6ae7bccc33ec7346d3b5c89a9ad
  $s$fMonadResourceResourceT_$s$fMonadThrowExceptT ::
    Control.Monad.Catch.MonadThrow
      (Control.Monad.Trans.Except.ExceptT e GHC.Types.IO)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e1.
                  @ (Control.Monad.Trans.Except.ExceptT e1 GHC.Types.IO)
                  (HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadThrowExceptT_$cp1MonadThrow
                     @ e1)
                  (Control.Monad.Catch.$fMonadThrowExceptT_$cthrowM
                     @ GHC.Types.IO
                     @ e1
                     Control.Monad.Catch.$fMonadThrowIO) -}
9dbbfe13aefa9299959b4e5a5ea1985c
  $s$fMonadResourceResourceT_$s$fMonadThrowResourceT ::
    Control.Monad.Catch.MonadThrow
      (Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Resource.Internal.ResourceT
                       (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
                  HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadIOResourceT_$cp1MonadIO
                  HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadThrowResourceT_$cthrowM -}
8447497e624a217f8474e67ed8817bc5
  $s$fMonadResourceResourceT_$s$fMonadThrowResourceT_$cthrowM ::
    GHC.Exception.Exception e =>
    e
    -> Control.Monad.Trans.Resource.Internal.ResourceT
         (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO) a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <B,1*U(A,A,1*C1(U),A,A)><B,U><B,A><B,U>b,
     Unfolding: InlineRule (1, True, False)
                (\ @ e1 @ a (eta :: GHC.Exception.Exception e1) ->
                 let {
                   g :: e1
                        -> Control.Monad.Trans.Except.ExceptT
                             GHC.Base.String GHC.Types.IO a
                   = Control.Monad.Catch.$fMonadThrowExceptT_$cthrowM
                       @ GHC.Types.IO
                       @ [GHC.Types.Char]
                       Control.Monad.Catch.$fMonadThrowIO
                       @ e1
                       @ a
                       eta
                 } in
                 \ (x :: e1) ->
                 let {
                   eta1 :: Control.Monad.Trans.Except.ExceptT
                             GHC.Base.String GHC.Types.IO a
                   = g x
                 } in
                 (\ (ds2 :: GHC.IORef.IORef
                              Control.Monad.Trans.Resource.Internal.ReleaseMap) ->
                  eta1)
                   `cast`
                 (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                           <Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO>_R
                           <a>_N))) -}
c66b53b0beceec4108012c04739c160f
  $tc'ByteStringToMatrix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17764067712948442535##
                   7856643583250121140##
                   HML.FileIO.MatrixSource.$trModule
                   HML.FileIO.MatrixSource.$tc'ByteStringToMatrix1) -}
34432519ad30513c55ec15a8796c6159
  $tc'ByteStringToMatrix1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ByteStringToMatrix"#) -}
ea402356e85a5ddfb271e37b6b22754c
  $tcByteStringToMatrix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6863445242028195593##
                   15208712312902022231##
                   HML.FileIO.MatrixSource.$trModule
                   HML.FileIO.MatrixSource.$tcByteStringToMatrix1) -}
4ecda9e8e89129e3cdeec9ca3d69be8e
  $tcByteStringToMatrix1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ByteStringToMatrix"#) -}
6383ee6f6fa8941a19558fb4ceee70d9
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   HML.FileIO.MatrixSource.$trModule2
                   HML.FileIO.MatrixSource.$trModule1) -}
0bd7ef60462612a8ffb753783412c47b
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HML.FileIO.MatrixSource"#) -}
b178b721d45c3b8db290de3ad2d80901
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "haslearned-0.1.0.0-1MYfuCwSlxlBXzMx3VqeuN"#) -}
9bd12bc170cbe24a95cfc69642375520
  $w$spoolMatrix ::
    GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Base.String
    -> (Data.ByteString.Internal.ByteString
        -> Data.Either.Either
             GHC.Base.String (Internal.Matrix.Matrix GHC.Types.Double))
    -> HML.FileIO.MatrixSource.MatrixConduit GHC.Types.Double
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,C(U)>, Inline: [0] -}
6c7c30444d155a004b2ecbd48b22b2cf
  $wloop ::
    GHC.Prim.Int#
    -> forall r.
       Data.Serialize.Get.Input
       -> Data.Serialize.Get.Buffer
       -> Data.Serialize.Get.More
       -> Data.Serialize.Get.Failure r
       -> Data.Serialize.Get.Success [GHC.Types.Double] r
       -> Data.Serialize.Get.Result r
  {- Arity: 6,
     Strictness: <S,U><L,U(U,U,U,U)><L,U><L,U><L,C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(U))))>,
     Inline: [0] -}
3b79d23b1057adff6aed540abed7e78b
  $wmatrixDoubleSource ::
    HML.Types.TypeName.TypeName
    -> HML.Types.PosInt.PosInt
    -> HML.Types.PosInt.PosInt
    -> GHC.IO.FilePath
    -> Data.Conduit.Internal.Conduit.ConduitM
         ()
         (Internal.Matrix.Matrix GHC.Types.Double)
         HML.FileIO.AppIO.AppIO
         ()
  {- Arity: 4, Strictness: <S,U><L,U(U)><L,U(U)><L,U>, Inline: [0] -}
a019314ecb5536cfc4ed05f3b8770644
  $wpoolMatrix ::
    GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Base.String
    -> (Data.ByteString.Internal.ByteString
        -> Data.Either.Either GHC.Base.String (Internal.Matrix.Matrix a))
    -> HML.FileIO.MatrixSource.MatrixConduit a
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,C(U)>, Inline: [0] -}
57d884e1c252b64ad0ca95eabcf8d4b5
  type role ByteStringToMatrix phantom
  data ByteStringToMatrix a
    = ByteStringToMatrix {context :: GHC.Base.String,
                          suggestion :: GHC.Base.Maybe GHC.Base.String,
                          transform :: Data.ByteString.Internal.ByteString
                                       -> Data.Either.Either
                                            GHC.Base.String (Internal.Matrix.Matrix a)}
20424cf87606ac642240252d128b9097
  type MatrixConduit a =
    Data.Conduit.Internal.Conduit.ConduitM
      Data.ByteString.Internal.ByteString
      (Internal.Matrix.Matrix a)
      HML.FileIO.AppIO.AppIO
      ()
44d4d452517eed91b05aca6d20a36d27
  confirmMatrixHeader ::
    HML.FileIO.MatrixHeader.MatrixHeader -> HML.FileIO.AppIO.Confirmer
  {- Arity: 2, Strictness: <L,U(U,U(U),U(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                HML.FileIO.MatrixSource.confirmMatrixHeader1
                  `cast`
                (<HML.FileIO.MatrixHeader.MatrixHeader>_R
                 ->_R Sym (Data.Conduit.Internal.Conduit.N:ConduitM[0]
                               <Data.ByteString.Internal.ByteString>_N
                               <Data.ByteString.Internal.ByteString>_N
                               <Control.Monad.Trans.Resource.Internal.ResourceT
                                  (Control.Monad.Trans.Except.ExceptT
                                     GHC.Base.String GHC.Types.IO)>_N
                               <()>_R)) -}
b40cd229710a712e3053e0ef7423e7c7
  confirmMatrixHeader1 ::
    HML.FileIO.MatrixHeader.MatrixHeader
    -> forall b.
       (()
        -> Data.Conduit.Internal.Pipe.Pipe
             Data.ByteString.Internal.ByteString
             Data.ByteString.Internal.ByteString
             Data.ByteString.Internal.ByteString
             ()
             (Control.Monad.Trans.Resource.Internal.ResourceT
                (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO))
             b)
       -> Data.Conduit.Internal.Pipe.Pipe
            Data.ByteString.Internal.ByteString
            Data.ByteString.Internal.ByteString
            Data.ByteString.Internal.ByteString
            ()
            HML.FileIO.AppIO.AppIO
            b
  {- Arity: 2, Strictness: <L,U(U,U(U),U(U))><L,U> -}
f157380e588ba4ef4d63779cc07db694
  context ::
    HML.FileIO.MatrixSource.ByteStringToMatrix a -> GHC.Base.String
  RecSel Left HML.FileIO.MatrixSource.ByteStringToMatrix
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: HML.FileIO.MatrixSource.ByteStringToMatrix a) ->
                 case ds2 of wild { HML.FileIO.MatrixSource.ByteStringToMatrix ds3 ds4 ds5 ->
                 ds3 }) -}
1cbc89857c3e56ade6622af0036494a5
  matrixDoubleSource ::
    HML.FileIO.MatrixHeader.MatrixHeader
    -> GHC.IO.FilePath
    -> Data.Conduit.Internal.Conduit.ConduitM
         ()
         (Internal.Matrix.Matrix GHC.Types.Double)
         HML.FileIO.AppIO.AppIO
         ()
  {- Arity: 2, Strictness: <S(SLL),1*U(U,U(U),U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: HML.FileIO.MatrixHeader.MatrixHeader)
                   (w1 :: GHC.IO.FilePath) ->
                 case w of ww { HML.FileIO.MatrixHeader.MatrixHeader ww1 ww2 ww3 ->
                 HML.FileIO.MatrixSource.$wmatrixDoubleSource ww1 ww2 ww3 w1 }) -}
ae28524cf18ab3d181a4cccb1cd8966b
  poolMatrix ::
    (Internal.Matrix.Element a, Foreign.Storable.Storable a) =>
    GHC.Types.Int
    -> HML.FileIO.MatrixSource.ByteStringToMatrix a
    -> HML.FileIO.MatrixSource.MatrixConduit a
  {- Arity: 4, Strictness: <L,A><L,A><L,U><S,1*U(U,U,C(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: Internal.Matrix.Element a)
                   (w1 :: Foreign.Storable.Storable a)
                   (w2 :: GHC.Types.Int)
                   (w3 :: HML.FileIO.MatrixSource.ByteStringToMatrix a) ->
                 case w3 of ww { HML.FileIO.MatrixSource.ByteStringToMatrix ww1 ww2 ww3 ->
                 HML.FileIO.MatrixSource.$wpoolMatrix @ a w2 ww1 ww2 ww3 }) -}
e527c718acda936e5837ea156193aa82
  poolMatrixDouble ::
    HML.Types.PosInt.PosInt
    -> HML.Types.PosInt.PosInt
    -> HML.FileIO.MatrixSource.MatrixConduit GHC.Types.Double
  {- Arity: 2, Strictness: <L,U(U)><L,U(U)>,
     Unfolding: (\ (nRows :: HML.Types.PosInt.PosInt)
                   (nCols :: HML.Types.PosInt.PosInt) ->
                 HML.FileIO.MatrixSource.$w$spoolMatrix
                   (case nRows
                           `cast`
                         (Test.QuickCheck.Modifiers.N:Positive[0]
                              <GHC.Types.Int>_R) of wild { GHC.Types.I# x ->
                    case nCols
                           `cast`
                         (Test.QuickCheck.Modifiers.N:Positive[0]
                              <GHC.Types.Int>_R) of wild1 { GHC.Types.I# y ->
                    GHC.Types.I# (GHC.Prim.*# (GHC.Prim.*# x y) 8#) } })
                   HML.FileIO.MatrixSource.poolMatrixDouble3
                   HML.FileIO.MatrixSource.poolMatrixDouble1
                   (Data.Serialize.Get.runGet
                      @ (Internal.Matrix.Matrix GHC.Types.Double)
                      (let {
                         m :: Data.Serialize.Get.Get [GHC.Types.Double]
                         = case nRows
                                  `cast`
                                (Test.QuickCheck.Modifiers.N:Positive[0]
                                     <GHC.Types.Int>_R) of wild { GHC.Types.I# x ->
                           case nCols
                                  `cast`
                                (Test.QuickCheck.Modifiers.N:Positive[0]
                                     <GHC.Types.Int>_R) of wild1 { GHC.Types.I# y ->
                           let {
                             w :: GHC.Prim.Int# = GHC.Prim.*# x y
                           } in
                           (\ @ r
                              (w1 :: Data.Serialize.Get.Input)
                              (w2 :: Data.Serialize.Get.Buffer)
                              (w3 :: Data.Serialize.Get.More)
                              (w4 :: Data.Serialize.Get.Failure r)
                              (w5 :: Data.Serialize.Get.Success [GHC.Types.Double] r) ->
                            HML.FileIO.MatrixSource.$wloop w @ r w1 w2 w3 w4 w5)
                             `cast`
                           (Sym (Data.Serialize.Get.N:Get[0] <[GHC.Types.Double]>_R)) } }
                       } in
                       (\ @ r
                          (s0 :: Data.Serialize.Get.Input)
                          (b0 :: Data.Serialize.Get.Buffer)[OneShot]
                          (m0 :: Data.Serialize.Get.More)[OneShot]
                          (kf :: Data.Serialize.Get.Failure r)[OneShot]
                          (ks :: Data.Serialize.Get.Success
                                   (Internal.Matrix.Matrix GHC.Types.Double) r)[OneShot] ->
                        m `cast` (Data.Serialize.Get.N:Get[0] <[GHC.Types.Double]>_R)
                          @ r
                          s0
                          b0
                          m0
                          kf
                          (\ (s1 :: Data.Serialize.Get.Input)
                             (b1 :: Data.Serialize.Get.Buffer)
                             (m1 :: Data.Serialize.Get.More)
                             (a1 :: [GHC.Types.Double]) ->
                           ks
                             s1
                             b1
                             m1
                             (case nRows
                                     `cast`
                                   (Test.QuickCheck.Modifiers.N:Positive[0]
                                        <GHC.Types.Int>_R) of ww { GHC.Types.I# ww1 ->
                              case nCols
                                     `cast`
                                   (Test.QuickCheck.Modifiers.N:Positive[0]
                                        <GHC.Types.Int>_R) of ww2 { GHC.Types.I# ww3 ->
                              case Internal.Element.$w><
                                     @ GHC.Types.Double
                                     Foreign.Storable.$fStorableDouble
                                     ww1
                                     ww3
                                     a1 of ww4 { (#,,,,,,#) ww5 ww6 ww7 ww8 ww9 ww10 ww11 ->
                              Internal.Matrix.Matrix
                                @ GHC.Types.Double
                                ww5
                                ww6
                                ww7
                                ww8
                                ww9
                                ww10
                                ww11 } } })))
                         `cast`
                       (Sym (Data.Serialize.Get.N:Get[0]
                                 <Internal.Matrix.Matrix GHC.Types.Double>_R))))) -}
4f8dd82e60ff81e77649bb76767b4e63
  poolMatrixDouble1 :: GHC.Base.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ [GHC.Types.Char]
                   HML.FileIO.MatrixSource.poolMatrixDouble2) -}
9146285442ecebb8983a67d1ea466f8c
  poolMatrixDouble2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Does the data have the right shape?"#) -}
78c424ff96c1ea801aeff0357601afe4
  poolMatrixDouble3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Parsing matrix"#) -}
45d1275b2f30eab00ad5ec3e6cacd304
  suggestion ::
    HML.FileIO.MatrixSource.ByteStringToMatrix a
    -> GHC.Base.Maybe GHC.Base.String
  RecSel Left HML.FileIO.MatrixSource.ByteStringToMatrix
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: HML.FileIO.MatrixSource.ByteStringToMatrix a) ->
                 case ds2 of wild { HML.FileIO.MatrixSource.ByteStringToMatrix ds3 ds4 ds5 ->
                 ds4 }) -}
fab99b24328d4e176328ffbdb69733d0
  transform ::
    HML.FileIO.MatrixSource.ByteStringToMatrix a
    -> Data.ByteString.Internal.ByteString
    -> Data.Either.Either GHC.Base.String (Internal.Matrix.Matrix a)
  RecSel Left HML.FileIO.MatrixSource.ByteStringToMatrix
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: HML.FileIO.MatrixSource.ByteStringToMatrix a) ->
                 case ds2 of wild { HML.FileIO.MatrixSource.ByteStringToMatrix ds3 ds4 ds5 ->
                 ds5 }) -}
"SPEC/HML.FileIO.MatrixSource $fApplicativeExceptT @ IO _" [ALWAYS] forall @ e1
                                                                           ($dMonad :: GHC.Base.Monad
                                                                                         GHC.Types.IO)
                                                                           ($dFunctor :: GHC.Base.Functor
                                                                                           GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT @ GHC.Types.IO
                                                  @ e1
                                                  $dFunctor
                                                  $dMonad
  = HML.FileIO.MatrixSource.$s$fApplicativeExceptT @ e1
"SPEC/HML.FileIO.MatrixSource $fApplicativeExceptT_$cp1Applicative @ IO _" [ALWAYS] forall @ e1
                                                                                           ($dMonad :: GHC.Base.Monad
                                                                                                         GHC.Types.IO)
                                                                                           ($dFunctor :: GHC.Base.Functor
                                                                                                           GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cp1Applicative @ GHC.Types.IO
                                                                  @ e1
                                                                  $dFunctor
                                                                  $dMonad
  = HML.FileIO.MatrixSource.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cp1Applicative
      @ e1
"SPEC/HML.FileIO.MatrixSource $fApplicativeExceptT_$cpure @ IO _" [ALWAYS] forall @ e1
                                                                                  ($dMonad :: GHC.Base.Monad
                                                                                                GHC.Types.IO)
                                                                                  ($dFunctor :: GHC.Base.Functor
                                                                                                  GHC.Types.IO)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ GHC.Types.IO
                                                         @ e1
                                                         $dFunctor
                                                         $dMonad
  = HML.FileIO.MatrixSource.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e1
"SPEC/HML.FileIO.MatrixSource $fApplicativeResourceT @ (ExceptT
                                                         String IO)" [ALWAYS] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                            GHC.Base.String
                                                                                                                                                                            GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fApplicativeResourceT @ (Control.Monad.Trans.Except.ExceptT
                                                                    GHC.Base.String GHC.Types.IO)
                                                               $dApplicative
  = HML.FileIO.MatrixSource.$s$fApplicativeResourceT
"SPEC/HML.FileIO.MatrixSource $fApplicativeResourceT_$cp1Applicative @ (ExceptT
                                                                         String IO)" [ALWAYS] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                            GHC.Base.String
                                                                                                                                                                                                            GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fApplicativeResourceT_$cp1Applicative @ (Control.Monad.Trans.Except.ExceptT
                                                                                    GHC.Base.String
                                                                                    GHC.Types.IO)
                                                                               $dApplicative
  = HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$s$fApplicativeResourceT_$cp1Applicative
"SPEC/HML.FileIO.MatrixSource $fApplicativeResourceT_$cpure @ (ExceptT
                                                                String IO)" [ALWAYS] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                       (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                          GHC.Base.String
                                                                                                                                                                                          GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fApplicativeResourceT_$cpure @ (Control.Monad.Trans.Except.ExceptT
                                                                           GHC.Base.String
                                                                           GHC.Types.IO)
                                                                      $dApplicative
  = HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$s$fApplicativeResourceT_$cpure
"SPEC/HML.FileIO.MatrixSource $fFunctorExceptT @ IO _" [ALWAYS] forall @ e1
                                                                       ($dFunctor :: GHC.Base.Functor
                                                                                       GHC.Types.IO)
  Control.Monad.Trans.Except.$fFunctorExceptT @ GHC.Types.IO
                                              @ e1
                                              $dFunctor
  = HML.FileIO.MatrixSource.$s$fApplicativeExceptT_$s$fFunctorExceptT
      @ e1
"SPEC/HML.FileIO.MatrixSource $fFunctorExceptT_$cfmap @ IO _" [ALWAYS] forall @ e1
                                                                              ($dFunctor :: GHC.Base.Functor
                                                                                              GHC.Types.IO)
  Control.Monad.Trans.Except.$fFunctorExceptT_$cfmap @ GHC.Types.IO
                                                     @ e1
                                                     $dFunctor
  = HML.FileIO.MatrixSource.$s$fApplicativeExceptT_$s$fFunctorExceptT_$cfmap
      @ e1
"SPEC/HML.FileIO.MatrixSource $fFunctorResourceT @ (ExceptT
                                                     String IO)" [ALWAYS] forall ($dFunctor :: GHC.Base.Functor
                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                GHC.Base.String
                                                                                                                                                                GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fFunctorResourceT @ (Control.Monad.Trans.Except.ExceptT
                                                                GHC.Base.String GHC.Types.IO)
                                                           $dFunctor
  = HML.FileIO.MatrixSource.$s$fApplicativeResourceT_$s$fFunctorResourceT
"SPEC/HML.FileIO.MatrixSource $fMonadBasebContT_$cp1MonadBase @ IO @ IO _" [ALWAYS] forall @ r
                                                                                           ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                             GHC.Types.IO
                                                                                                             GHC.Types.IO)
  Control.Monad.Base.$fMonadBasebContT_$cp1MonadBase @ GHC.Types.IO
                                                     @ GHC.Types.IO
                                                     @ r
                                                     $dMonadBase
  = HML.FileIO.MatrixSource.$s$fMonadBasebContT_$cp1MonadBase @ r
"SPEC/HML.FileIO.MatrixSource $fMonadBasebContT_$cp3MonadBase @ IO @ IO _" [ALWAYS] forall @ r
                                                                                           ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                             GHC.Types.IO
                                                                                                             GHC.Types.IO)
  Control.Monad.Base.$fMonadBasebContT_$cp3MonadBase @ GHC.Types.IO
                                                     @ GHC.Types.IO
                                                     @ r
                                                     $dMonadBase
  = HML.FileIO.MatrixSource.$s$fMonadBasebContT_$cp3MonadBase @ r
"SPEC/HML.FileIO.MatrixSource $fMonadBasebExceptT @ IO @ IO _" [ALWAYS] forall @ e1
                                                                               ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                 GHC.Types.IO
                                                                                                 GHC.Types.IO)
  Control.Monad.Base.$fMonadBasebExceptT @ GHC.Types.IO
                                         @ GHC.Types.IO
                                         @ e1
                                         $dMonadBase
  = HML.FileIO.MatrixSource.$s$fMonadBasebExceptT @ e1
"SPEC/HML.FileIO.MatrixSource $fMonadBasebResourceT @ IO @ (ExceptT
                                                             String IO)" [ALWAYS] forall ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                                                                                               GHC.Types.IO
                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                  GHC.Base.String
                                                                                                                                                                                  GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadBasebResourceT @ GHC.Types.IO
                                                              @ (Control.Monad.Trans.Except.ExceptT
                                                                   GHC.Base.String GHC.Types.IO)
                                                              $dMonadBase
  = HML.FileIO.MatrixSource.$s$fMonadBasebResourceT
"SPEC/HML.FileIO.MatrixSource $fMonadBasebResourceT_$cliftBase @ IO @ (ExceptT
                                                                        String IO)" [ALWAYS] forall ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                                                                                                                     GHC.Types.IO
                                                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                        GHC.Base.String
                                                                                                                                                                                                        GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadBasebResourceT_$cliftBase @ GHC.Types.IO
                                                                         @ (Control.Monad.Trans.Except.ExceptT
                                                                              GHC.Base.String
                                                                              GHC.Types.IO)
                                                                         $dMonadBase
  = HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadBasebResourceT_$cliftBase
"SPEC/HML.FileIO.MatrixSource $fMonadBasebResourceT_$cp2MonadBase @ IO @ (ExceptT
                                                                           String IO)" [ALWAYS] forall ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                                                                                                                           GHC.Types.IO
                                                                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                              GHC.Base.String
                                                                                                                                                                                                              GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadBasebResourceT_$cp2MonadBase @ GHC.Types.IO
                                                                            @ (Control.Monad.Trans.Except.ExceptT
                                                                                 GHC.Base.String
                                                                                 GHC.Types.IO)
                                                                            $dMonadBase
  = HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadBasebResourceT_$cp2MonadBase
"SPEC/HML.FileIO.MatrixSource $fMonadExceptT @ IO _" [ALWAYS] forall @ e1
                                                                     ($dMonad :: GHC.Base.Monad
                                                                                   GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT @ GHC.Types.IO
                                            @ e1
                                            $dMonad
  = HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadExceptT
      @ e1
"SPEC/HML.FileIO.MatrixSource $fMonadExceptT_$c>> @ IO _" [ALWAYS] forall @ e1
                                                                          ($dMonad :: GHC.Base.Monad
                                                                                        GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT_$c>> @ GHC.Types.IO
                                                 @ e1
                                                 $dMonad
  = HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadExceptT_$c>>
      @ e1
"SPEC/HML.FileIO.MatrixSource $fMonadExceptT_$c>>= @ IO _" [ALWAYS] forall @ e1
                                                                           ($dMonad :: GHC.Base.Monad
                                                                                         GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT_$c>>= @ GHC.Types.IO
                                                  @ e1
                                                  $dMonad
  = HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadExceptT_$c>>=
      @ e1
"SPEC/HML.FileIO.MatrixSource $fMonadExceptT_$cp1Monad @ IO _" [ALWAYS] forall @ e1
                                                                               ($dMonad :: GHC.Base.Monad
                                                                                             GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadExceptT_$cp1Monad @ GHC.Types.IO
                                                      @ e1
                                                      $dMonad
  = HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadExceptT_$cp1Monad
      @ e1
"SPEC/HML.FileIO.MatrixSource $fMonadIOExceptT @ IO _" [ALWAYS] forall @ e1
                                                                       ($dMonadIO :: Control.Monad.IO.Class.MonadIO
                                                                                       GHC.Types.IO)
  Control.Monad.Trans.Except.$fMonadIOExceptT @ GHC.Types.IO
                                              @ e1
                                              $dMonadIO
  = HML.FileIO.MatrixSource.$s$fMonadIOExceptT @ e1
"SPEC/HML.FileIO.MatrixSource $fMonadIOResourceT @ (ExceptT
                                                     String IO)" [ALWAYS] forall ($dMonadIO :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                GHC.Base.String
                                                                                                                                                                GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadIOResourceT @ (Control.Monad.Trans.Except.ExceptT
                                                                GHC.Base.String GHC.Types.IO)
                                                           $dMonadIO
  = HML.FileIO.MatrixSource.$s$fMonadIOResourceT
"SPEC/HML.FileIO.MatrixSource $fMonadIOResourceT_$cp1MonadIO @ (ExceptT
                                                                 String IO)" [ALWAYS] forall ($dMonadIO :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                        GHC.Base.String
                                                                                                                                                                                        GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadIOResourceT_$cp1MonadIO @ (Control.Monad.Trans.Except.ExceptT
                                                                            GHC.Base.String
                                                                            GHC.Types.IO)
                                                                       $dMonadIO
  = HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadIOResourceT_$cp1MonadIO
"SPEC/HML.FileIO.MatrixSource $fMonadResourceResourceT @ (ExceptT
                                                           String IO)" [ALWAYS] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                GHC.Base.String
                                                                                                                                                                                GHC.Types.IO))
                                                                                                                                                         ($dMonadIO :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                                         (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                            GHC.Base.String
                                                                                                                                                                            GHC.Types.IO))
                                                                                                                                                         ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                                                                                           GHC.Types.IO
                                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                              GHC.Base.String
                                                                                                                                                                              GHC.Types.IO))
                                                                                                                                                         ($dMonadThrow :: Control.Monad.Catch.MonadThrow
                                                                                                                                                                            (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                               GHC.Base.String
                                                                                                                                                                               GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadResourceResourceT @ (Control.Monad.Trans.Except.ExceptT
                                                                      GHC.Base.String GHC.Types.IO)
                                                                 $dMonadThrow
                                                                 $dMonadBase
                                                                 $dMonadIO
                                                                 $dApplicative
  = HML.FileIO.MatrixSource.$s$fMonadResourceResourceT
"SPEC/HML.FileIO.MatrixSource $fMonadResourceResourceT_$cp1MonadResource @ (ExceptT
                                                                             String IO)" [ALWAYS] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                    GHC.Base.String
                                                                                                                                                                                                                    GHC.Types.IO))
                                                                                                                                                                                             ($dMonadIO :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                GHC.Base.String
                                                                                                                                                                                                                GHC.Types.IO))
                                                                                                                                                                                             ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                                                                                                                               GHC.Types.IO
                                                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                  GHC.Base.String
                                                                                                                                                                                                                  GHC.Types.IO))
                                                                                                                                                                                             ($dMonadThrow :: Control.Monad.Catch.MonadThrow
                                                                                                                                                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                   GHC.Base.String
                                                                                                                                                                                                                   GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadResourceResourceT_$cp1MonadResource @ (Control.Monad.Trans.Except.ExceptT
                                                                                        GHC.Base.String
                                                                                        GHC.Types.IO)
                                                                                   $dMonadThrow
                                                                                   $dMonadBase
                                                                                   $dMonadIO
                                                                                   $dApplicative
  = HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadResourceResourceT_$cp1MonadResource
"SPEC/HML.FileIO.MatrixSource $fMonadResourceResourceT_$cp2MonadResource @ (ExceptT
                                                                             String IO)" [ALWAYS] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                    GHC.Base.String
                                                                                                                                                                                                                    GHC.Types.IO))
                                                                                                                                                                                             ($dMonadIO :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                GHC.Base.String
                                                                                                                                                                                                                GHC.Types.IO))
                                                                                                                                                                                             ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                                                                                                                               GHC.Types.IO
                                                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                  GHC.Base.String
                                                                                                                                                                                                                  GHC.Types.IO))
                                                                                                                                                                                             ($dMonadThrow :: Control.Monad.Catch.MonadThrow
                                                                                                                                                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                   GHC.Base.String
                                                                                                                                                                                                                   GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadResourceResourceT_$cp2MonadResource @ (Control.Monad.Trans.Except.ExceptT
                                                                                        GHC.Base.String
                                                                                        GHC.Types.IO)
                                                                                   $dMonadThrow
                                                                                   $dMonadBase
                                                                                   $dMonadIO
                                                                                   $dApplicative
  = HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadResourceResourceT_$cp2MonadResource
"SPEC/HML.FileIO.MatrixSource $fMonadResourceResourceT_$cp4MonadResource @ (ExceptT
                                                                             String IO)" [ALWAYS] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                    GHC.Base.String
                                                                                                                                                                                                                    GHC.Types.IO))
                                                                                                                                                                                             ($dMonadIO :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                GHC.Base.String
                                                                                                                                                                                                                GHC.Types.IO))
                                                                                                                                                                                             ($dMonadBase :: Control.Monad.Base.MonadBase
                                                                                                                                                                                                               GHC.Types.IO
                                                                                                                                                                                                               (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                  GHC.Base.String
                                                                                                                                                                                                                  GHC.Types.IO))
                                                                                                                                                                                             ($dMonadThrow :: Control.Monad.Catch.MonadThrow
                                                                                                                                                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                                   GHC.Base.String
                                                                                                                                                                                                                   GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadResourceResourceT_$cp4MonadResource @ (Control.Monad.Trans.Except.ExceptT
                                                                                        GHC.Base.String
                                                                                        GHC.Types.IO)
                                                                                   $dMonadThrow
                                                                                   $dMonadBase
                                                                                   $dMonadIO
                                                                                   $dApplicative
  = HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadResourceResourceT_$cp4MonadResource
"SPEC/HML.FileIO.MatrixSource $fMonadResourceT @ (ExceptT String IO)" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                                                                    (Control.Monad.Trans.Except.ExceptT
                                                                                                       GHC.Base.String
                                                                                                       GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadResourceT @ (Control.Monad.Trans.Except.ExceptT
                                                              GHC.Base.String GHC.Types.IO)
                                                         $dMonad
  = HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadResourceT
"SPEC/HML.FileIO.MatrixSource $fMonadResourceT_$cfail @ (ExceptT
                                                          String IO)" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                        GHC.Base.String
                                                                                                                                                                        GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadResourceT_$cfail @ (Control.Monad.Trans.Except.ExceptT
                                                                     GHC.Base.String GHC.Types.IO)
                                                                $dMonad
  = HML.FileIO.MatrixSource.$s$fMonadBasebResourceT_$s$fMonadResourceT_$cfail
"SPEC/HML.FileIO.MatrixSource $fMonadThrowExceptT @ IO _" [ALWAYS] forall @ e1
                                                                          ($dMonadThrow :: Control.Monad.Catch.MonadThrow
                                                                                             GHC.Types.IO)
  Control.Monad.Catch.$fMonadThrowExceptT @ GHC.Types.IO
                                          @ e1
                                          $dMonadThrow
  = HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadThrowExceptT
      @ e1
"SPEC/HML.FileIO.MatrixSource $fMonadThrowExceptT_$cp1MonadThrow @ IO _" [ALWAYS] forall @ e1
                                                                                         ($dMonadThrow :: Control.Monad.Catch.MonadThrow
                                                                                                            GHC.Types.IO)
  Control.Monad.Catch.$fMonadThrowExceptT_$cp1MonadThrow @ GHC.Types.IO
                                                         @ e1
                                                         $dMonadThrow
  = HML.FileIO.MatrixSource.$s$fMonadBasebExceptT_$s$fMonadThrowExceptT_$cp1MonadThrow
      @ e1
"SPEC/HML.FileIO.MatrixSource $fMonadThrowResourceT @ (ExceptT
                                                        String IO)" [ALWAYS] forall ($dMonadThrow :: Control.Monad.Catch.MonadThrow
                                                                                                                                                                      (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                         GHC.Base.String
                                                                                                                                                                         GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadThrowResourceT @ (Control.Monad.Trans.Except.ExceptT
                                                                   GHC.Base.String GHC.Types.IO)
                                                              $dMonadThrow
  = HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadThrowResourceT
"SPEC/HML.FileIO.MatrixSource $fMonadThrowResourceT_$cthrowM @ (ExceptT
                                                                 String IO)" [ALWAYS] forall ($dMonadThrow :: Control.Monad.Catch.MonadThrow
                                                                                                                                                                                        (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                           GHC.Base.String
                                                                                                                                                                                           GHC.Types.IO))
  Control.Monad.Trans.Resource.Internal.$fMonadThrowResourceT_$cthrowM @ (Control.Monad.Trans.Except.ExceptT
                                                                            GHC.Base.String
                                                                            GHC.Types.IO)
                                                                       $dMonadThrow
  = HML.FileIO.MatrixSource.$s$fMonadResourceResourceT_$s$fMonadThrowResourceT_$cthrowM
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

