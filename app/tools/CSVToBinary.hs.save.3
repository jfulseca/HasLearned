import Conduit (runConduitRes)
import Control.Monad.Trans.Except (runExceptT)
import Data.Semigroup ((<>))
import HML.FileIO.CSVReader
import HML.FileIO.MatrixHeader (MatrixHeader(..))
import HML.Types.PosInt (posInt)
import HML.Types.TypeName (TypeName(..))
import Options.Applicative

data Conversion = Conversion { inFile :: String
                             , outFile :: String
                             , nRows :: Int
                             , nCols :: Int }

conversion :: Parser Conversion
conversion = Conversion
  <$> strOption (long "in-file"
              <> short 'i'
              <> metavar "INPUT"
              <> help "Input file (csv)")
  <*> strOption (long "out-file"
              <> short 'o'
              <> metavar "OUTPUT"
              <> help "Output file (binary)")
  <*> option auto (long "rows"
                <> short 'r'
                <> metavar "ROWS"
                <> help "Number of rows")
  <*> option auto (long "columns"
                <> short 'c'
                <> metavar "COLUMNS"
                <> help "Number of columns")

description :: String
description = "Converts a csv file of numbers "
           ++ "to a row order double matrix "
           ++ "in a native format binary file"

title :: String
title = "CSVToBinary"

failPosInt :: IO ()
failPosInt = do
  putStrLn $ "Both rows and columns must be "
          ++ "positive integers"
  return ()

convert :: Conversion -> IO ()
convert args = do
  let mDims = sequence .posInt
    <$> (nRows args, nCols args)
  case mDims of
    Nothinf
  let matrixHeader = MatrixHeader DBL r c
  result <- runExceptT . runConduitRes $
    csvToBinary (inFile args)
                (outFile args)
                matrixHeader
  return ()

main :: IO ()
main = convert =<< execParser opts
  where opts = info (conversion <**> helper)
                    (fullDesc
                  <> progDesc description
                  <> header title)
